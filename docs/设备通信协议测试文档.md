# 4G设备-后台通信协议 · 完整测试文档

## 1. 概述

本文档描述旧物回收系统中 **4G设备与后台服务** 之间通信协议的完整测试方案。测试脚本位于 `backend/scripts/test_heartbeat.py`。

### 1.1 测试目标

验证《旧物回收通信协议.docx》中定义的所有消息类型和交互流程，包括 **WebSocket 长连接通信**：

| 方向 | 消息类型 | 说明 |
|------|----------|------|
| 设备→后台 | `device_status_report` | 设备状态上报（含传感器+摄像头） |
| 设备→后台 | `heartbeat_report` | 心跳包上报 |
| 后台→设备 | `server_ack` | 服务器应答 |
| 后台→设备 | `time_sync` | 时间同步消息 |
| 后台→设备 | `query_device_status` | 主动查询设备状态 |
| 双向 | **WebSocket** | **⭐ 统一通信通道（v3.0 新增）** |

### 1.2 "首次上报"判断逻辑

后台通过 `devices` 表的 **`first_report_at`** 字段判断设备是否首次上报数据：

| `first_report_at` 值 | 含义 | time_sync 触发 |
|----------------------|------|----------------|
| `NULL` | 设备从未上报过数据，视为首次上报 | ✅ 触发 |
| 非 `NULL` (有时间戳) | 设备已上报过数据，非首次上报 | ❌ 不触发 |

> **注意**：`is_using` 字段仅表示设备当前是否有人使用，**与首次上报判断无关**。

### 1.3 运行方式

```bash
# 全部测试（需要后端服务运行）
python3 backend/scripts/test_heartbeat.py

# 仅离线测试（不需要后端服务）
python3 backend/scripts/test_heartbeat.py --offline-only

# 指定 API 地址
python3 backend/scripts/test_heartbeat.py --api http://localhost:8000/api/v1
```

### 1.4 配置项

| 配置 | 默认值 | 说明 |
|------|--------|------|
| `API_BASE_URL` | `http://42.194.134.223:8000/api/v1` | 后端API地址 |
| `DEVICE_ID` | `DEV001` | 测试设备ID |
| `ADMIN_USERNAME` | `admin` | 管理员账号 |
| `ADMIN_PASSWORD` | `admin123` | 管理员密码 |

### 1.5 测试前准备

为确保 T1 和 T14（首次上报）测试能正确验证 `time_sync` 触发，需要重置设备的 `first_report_at` 字段：

```sql
-- 在 MySQL 中执行
UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';
```

---

## 2. 测试用例详细说明

### 2.1 离线测试

#### P1: Base64 PNG 图片生成验证

| 项目 | 内容 |
|------|------|
| **目的** | 验证纯Python生成的PNG图片是否合法 |
| **前置条件** | 无（不需要网络） |
| **测试步骤** | 生成4种不同颜色的PNG图片，验证格式 |
| **验证项** | ① PNG头部签名(89 50 4E 47) ② Base64编码以 `iVBOR` 开头 |
| **预期结果** | 4张图片全部通过PNG格式验证 |

**实际测试结果：**
```
✅ PASS | P1: Base64 PNG 图片生成
ℹ️  4 张图片全部验证通过
```

#### P2: MD5 校验码计算与验证

| 项目 | 内容 |
|------|------|
| **目的** | 验证MD5校验码算法实现正确 |
| **前置条件** | 无 |
| **校验规则** | `MD5(包头 + JSON数据体(不含check_code))`，32位小写 |
| **验证项** | ① 正确校验码匹配 ② 错误校验码不匹配 ③ 包头参与校验（有包头和无包头结果不同） |
| **预期结果** | 3个场景全部验证通过 |

**实际测试结果：**
```
✅ PASS | P2: MD5 校验码验证
```

---

### 2.2 在线测试 - WebSocket 通信（优先）

#### T12: WebSocket 连接 + 心跳 ⭐⭐ (v3.0 新增)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备可以通过 WebSocket 长连接发送心跳并收到 ack + time_sync |
| **端点** | `ws://server/api/v1/device/ws/{device_id}` |
| **核心机制** | 设备通过 WebSocket 双向长连接完成所有通信 |

**WebSocket 心跳流程:**

```
┌──────┐    步骤1: WebSocket 连接             ┌──────┐
│ 设备 │ ═══════════════════════════════→    │ 后台 │  WebSocket 握手成功
│      │                                     │      │
│      │    步骤2: 发送 heartbeat_report      │      │
│ 设备 │ ──────────────────────────────→    │      │  后台处理心跳
│      │                                     │      │
│      │    步骤3: 收到 ack + time_sync       │      │
│ 设备 │ ←══════════════════════════════    │      │  后台下发应答+时间同步
│      │                                     │      │
│      │    步骤4: 断开连接                    │      │
│ 设备 │ ═══════════════════════════════→    │      │  后台标记设备离线
└──────┘                                     └──────┘
```

| 步骤 | 操作 | 预期 |
|------|------|------|
| 步骤1 | 建立 WebSocket 连接 | 连接成功，收到欢迎消息 |
| 步骤2 | 发送 heartbeat_report | 消息成功发送 |
| 步骤3 | 接收响应消息 | 收到 server_ack 和 time_sync |
| 步骤4 | 断开 WebSocket 连接 | 连接正常关闭 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| WebSocket 连接 | 成功 | 握手成功 |
| 欢迎消息 | 包含 device_id | 后台确认连接 |
| server_ack | 存在 | 心跳应答 |
| time_sync | 存在 | 心跳触发时间同步 |

**实际测试结果：**
```
✅ PASS | T12: WebSocket 心跳
ℹ️  同步时间: 2026-02-08 22:17:56

📥 收到消息1 (ack): {
  "msg_type": "server_ack",
  "device_id": "DEV001",
  "timestamp": "2026-02-08 22:17:56",
  "data": {
    "reply_msg_type": "heartbeat_report",
    "ack_code": 0,
    "ack_desc": "数据接收成功"
  },
  "check_code": "e107d87fac9c74077a071d27bf0c39b6"
}
📥 收到消息2 (time_sync): {
  "msg_type": "time_sync",
  "device_id": "DEV001",
  "timestamp": "2026-02-08 22:17:56",
  "data": {
    "standard_time": "2026-02-08 22:17:56"
  },
  "check_code": "dd716f191fbf2fa2436e5de20612a62d"
}
```

> 💡 测试需要安装 `websockets` 库：`pip install websockets`。如未安装，测试自动跳过。

---

#### T13: WebSocket 命令实时推送 ⭐⭐ (v3.0 新增)

| 项目 | 内容 |
|------|------|
| **目的** | 验证管理员下发的命令可以通过 WebSocket 实时推送到设备 |
| **端点** | `ws://server/api/v1/device/ws/{device_id}` |
| **核心机制** | 设备保持 WebSocket 连接，后台命令通过连接直接推送 |

**WebSocket 命令推送流程:**

```
┌──────┐    步骤1: WebSocket 连接             ┌──────┐
│ 设备 │ ═══════════════════════════════→    │ 后台 │  WebSocket 握手成功
│      │                                     │      │
│      │    步骤2: 管理员查询                  │      │
│ 管理 │ ──────────────────────────────→    │      │  POST /device/query-status
│ 员   │                                     │      │  delivery_method=websocket ✅
│      │                                     │      │
│ 设备 │ ←══════════════════════════════    │      │  步骤3: 通过 WS 推送命令
│      │    query_device_status              │      │
│      │                                     │      │
│ 设备 │ ──────────────────────────────→    │      │  步骤4: 设备通过 WS 上报状态
│      │    device_status_report             │      │
│      │                                     │      │
│ 设备 │ ←══════════════════════════════    │      │  步骤5: 收到 ack
│      │    server_ack                       │      │
└──────┘                                     └──────┘
```

| 步骤 | 操作 | 预期 |
|------|------|------|
| 步骤1 | 建立 WebSocket 连接 | 连接成功 |
| 步骤2 | 管理员调用 query-status | delivery_method=**websocket** |
| 步骤3 | 设备端 WS 接收 | 收到 query_device_status 命令 |
| 步骤4 | 设备通过 WS 上报状态 | 发送 device_status_report |
| 步骤5 | 接收 ack | 收到 server_ack |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| delivery_method | **websocket** | 命令通过 WebSocket 实时推送 |
| 设备收到的命令 | query_device_status | 命令类型正确 |
| 设备上报状态 | 成功 | 通过同一 WS 连接上报 |
| server_ack | 存在 | 上报应答正确 |

**实际测试结果：**
```
✅ PASS | T13: WebSocket 命令推送
ℹ️  WS连接✅、下发websocket✅、WS收到命令✅

📥 响应: {
  "code": 0,
  "message": "查询命令已通过 WebSocket 实时下发到设备",
  "data": {
    "delivery_method": "websocket",
    "delivery_desc": "WebSocket 实时推送",
    "device_online": true
  }
}
📥 收到命令: {
  "msg_type": "query_device_status",
  "device_id": "DEV001",
  "timestamp": "2026-02-08 22:17:57",
  "check_code": "897caef7f0e24a41d41db331b491acef"
}
```

> 💡 此测试验证了 WebSocket 作为统一通信通道的完整流程：连接 → 命令推送 → 状态上报 → 应答，全部通过同一条 WebSocket 连接完成。

---

#### T14: WebSocket 首次上报 → 触发时间同步 ⭐⭐ (v3.0 新增)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备通过 WebSocket 首次上报时，后台返回 ack + time_sync |
| **端点** | `ws://server/api/v1/device/ws/{device_id}` |
| **协议规定** | 首次上报（`first_report_at` 为 NULL），返回 ack + time_sync |
| **前置条件** | 设备 `first_report_at` 字段为 NULL |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| WebSocket 连接 | 成功 | |
| 发送 device_status_report | 成功 | 通过 WS 发送 |
| 收到消息1 (ack) | msg_type=server_ack, ack_code=0 | |
| 收到消息2 (time_sync) | msg_type=time_sync | 首次上报触发 |
| time_sync.data.standard_time | 当前服务器时间 | |

**实际测试结果：**
```
❌ FAIL | T14: WS 首次上报
ℹ️  设备已上报过数据，需重置 first_report_at

⚠️  未收到 time_sync！该设备可能已上报过数据(first_report_at 不为空)。
   请执行以下 SQL 后重新测试:
   UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';
```

> ⚠️ 与 T1 相同，需要 `first_report_at` 为 NULL。如测试失败：
> ```sql
> UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';
> ```

---

#### T15: WebSocket 状态上报（含摄像头）⭐⭐ (v3.0 新增)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备通过 WebSocket 上报含摄像头数据的状态，非首次上报不触发 time_sync |
| **端点** | `ws://server/api/v1/device/ws/{device_id}` |
| **前置条件** | 设备 `first_report_at` 已有值（由 T14 设置） |
| **发送数据** | `is_using=1`, camera_1×3 + camera_2×3 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| WebSocket 连接 | 成功 | |
| ack.msg_type | server_ack | |
| ack.data.ack_code | 0 | 接收成功 |
| ack.data.reply_msg_type | device_status_report | 应答对应上报类型 |
| time_sync | **不存在** | 非首次上报 |
| 摄像头图片 | 保存到数据库 | camera_1×3 + camera_2×3 |

**实际测试结果：**
```
✅ PASS | T15: WS 状态上报(含摄像头)

📥 收到消息1 (ack): {
  "msg_type": "server_ack",
  "device_id": "DEV001",
  "timestamp": "2026-02-08 22:18:00",
  "data": {
    "reply_msg_type": "device_status_report",
    "ack_code": 0,
    "ack_desc": "数据接收成功"
  },
  "check_code": "026b289682c9ee2fa827f513c5ffa01d"
}
📥 消息2: 无 (符合预期，非首次上报)
```

---

#### T16: WebSocket 烟感告警上报 ⭐⭐ (v3.0 新增)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备通过 WebSocket 上报烟感告警 + 现场照片 |
| **端点** | `ws://server/api/v1/device/ws/{device_id}` |
| **发送数据** | `smoke_sensor_status=1`, camera_1×2 + camera_2×1（红色调告警照片） |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| WebSocket 连接 | 成功 | |
| ack.msg_type | server_ack | |
| ack.data.ack_code | 0 | 接收成功 |
| ack.data.reply_msg_type | device_status_report | |
| 后台设备表 | smoke_sensor_status=1 | 告警状态被更新 |

**实际测试结果：**
```
✅ PASS | T16: WS 烟感告警上报

📥 收到 ack: {
  "msg_type": "server_ack",
  "device_id": "DEV001",
  "timestamp": "2026-02-08 22:18:03",
  "data": {
    "reply_msg_type": "device_status_report",
    "ack_code": 0,
    "ack_desc": "数据接收成功"
  },
  "check_code": "6627a885e3b1e52f75654d858d32e48a"
}
```

---

#### T17: WebSocket 错误校验码上报 ⭐⭐ (v3.0 新增)

| 项目 | 内容 |
|------|------|
| **目的** | 验证通过 WebSocket 发送校验码不匹配的报文时，后台正确拒绝 |
| **端点** | `ws://server/api/v1/device/ws/{device_id}` |
| **发送数据** | 正常报文但 check_code 被篡改为 `0000...ffff` |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| WebSocket 连接 | 成功 | |
| ack.msg_type | server_ack | |
| ack.data.ack_code | **1** | 校验失败 |
| ack.data.ack_desc | 包含"校验失败" | 失败原因描述 |
| ack.data.reply_msg_type | device_status_report | |

**实际测试结果：**
```
✅ PASS | T17: WS 错误校验码

📥 收到 ack: {
  "msg_type": "server_ack",
  "device_id": "DEV001",
  "timestamp": "2026-02-08 22:18:03",
  "data": {
    "reply_msg_type": "device_status_report",
    "ack_code": 1,
    "ack_desc": "校验失败"
  },
  "check_code": "e3ac0086b440e053b111ccb2475e6a44"
}
```

> 💡 WebSocket 通道与 HTTP 通道共用同一套校验逻辑，T17 验证了这一点在 WebSocket 路径上也能正确工作。

---

### 2.3 在线测试 - HTTP 通信（兼容）

#### T1: 首次上报 → 触发时间同步 (first_report_at=NULL) ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备首次向后台上报数据时，后台返回 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **协议规定** | 设备首次上报数据时（`first_report_at` 为 NULL），除了返回 ack 消息，还需返回 time_sync 消息 |
| **前置条件** | 设备 `first_report_at` 字段为 NULL |
| **发送数据** | `msg_type=device_status_report`, `is_using=0`, `battery=85` |

**预期响应:**

```
HTTP 200
{
  "code": 0,
  "data": {
    "ack": { ... server_ack ... },       ← ✅ 存在
    "time_sync": {                        ← ✅ 存在（首次上报触发）
      "msg_type": "time_sync",
      "device_id": "DEV001",
      "data": {
        "standard_time": "2026-02-08 14:30:00"  ← 当前服务器时间
      }
    }
  }
}
```

| 验证项 | 预期 | 说明 |
|--------|------|------|
| HTTP 状态码 | 200 | |
| code | 0 | 处理成功 |
| data.ack | 存在 | 服务器应答 |
| data.time_sync | **存在** | first_report_at 为 NULL，触发时间同步 |
| time_sync.data.standard_time | 当前服务器时间 | 用于设备校时 |

**实际测试结果：**
```
✅ PASS | T1: 首次上报时间同步
ℹ️  同步时间: 2026-02-08 22:17:54
```

> ⚠️ 如果测试结果中 time_sync 未出现，说明设备之前已上报过数据。请执行以下 SQL 后重新测试：
> ```sql
> UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';
> ```

---

#### T2: 非首次上报 (含摄像头)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备已上报过数据后，后续上报不再触发 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **前置条件** | 设备 `first_report_at` 已有值（由 T1 设置） |
| **发送数据** | `is_using=1`, 含 camera_1×3 + camera_2×3 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **不存在** | first_report_at 已有值，非首次上报 |
| 摄像头图片 | 保存到数据库 | camera_1×3 + camera_2×3 |

**实际测试结果：**
```
✅ PASS | T2: 非首次上报(含摄像头)
```

---

#### T3: 持续使用上报 (is_using=1, 含摄像头)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备持续使用中的上报，非首次不触发 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **前置条件** | 设备 `first_report_at` 已有值 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **不存在** | 非首次上报，不触发 |
| 摄像头图片 | 保存到数据库 | 新的一批图片 |

**实际测试结果：**
```
✅ PASS | T3: 持续使用上报(含摄像头)
```

---

#### T4: 烟感告警上报 (smoke_sensor_status=1, 含告警照片)

| 项目 | 内容 |
|------|------|
| **目的** | 验证烟感告警时的状态上报和图片保存 |
| **接口** | `POST /api/v1/device/report` |
| **发送数据** | `smoke_sensor_status=1`, camera_1×2 (红色调告警场景), camera_2×1 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| ack.data.ack_code | 0 | 接收成功 |
| 后台设备表 | smoke_sensor_status=1 | 告警状态被更新 |
| 管理后台 | 显示烟感告警标红 | 仪表盘告警计数+1 |

**实际测试结果：**
```
✅ PASS | T4: 烟感告警上报(含现场照片)
```

---

#### T5: 使用结束上报 (is_using: 1→0)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备使用结束恢复空闲时不触发 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **协议说明** | time_sync 仅在首次上报和心跳时触发 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **不存在** | 非首次上报，不触发时间同步 |

**实际测试结果：**
```
✅ PASS | T5: 使用结束上报
```

---

#### T6: 心跳上报 (无待执行命令) ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证心跳上报后，后台下发时间同步 |
| **接口** | `POST /api/v1/device/heartbeat` |
| **协议规定** | 后台收到设备心跳包后，下发 time_sync 消息 |

**预期响应:**

```
HTTP 200
{
  "code": 0,
  "data": {
    "ack": { ... },                       ← ✅ 存在
    "time_sync": {                        ← ✅ 存在（心跳触发时间同步）
      "data": {
        "standard_time": "2026-02-08 14:35:00"
      }
    }
    // 无 command                          ← ✅ 不存在（无待执行命令）
  }
}
```

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **存在** | 心跳触发时间同步 |
| data.command | **不存在** | 无待执行命令 |

**实际测试结果：**
```
✅ PASS | T6: 心跳上报(time_sync)
ℹ️  同步时间: 2026-02-08 22:17:55
```

---

#### T7: 后台主动查询设备状态 - 实时下发流程 ⭐⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证 query_device_status 通过长轮询实时下发到设备的完整流程 |
| **核心机制** | 设备通过 `GET /device/listen/{device_id}` 长轮询保持监听，后台通过 `asyncio.Queue` 实时推送命令 |

**实时下发流程:**

```
┌──────┐    步骤1: GET /device/listen      ┌──────┐
│ 设备 │ ═══════════════════════════════→  │ 后台 │  设备启动长轮询监听(连接保持)
│      │                                   │      │
│      │    步骤2: POST /query-status       │      │
│ 管理 │ ──────────────────────────────→  │      │  后台下发命令(delivery=realtime)
│ 员   │                                   │      │  → asyncio.Queue 实时推送
│      │                                   │      │
│ 设备 │ ←═══════════════════════════════ │      │  步骤3: 设备立即收到命令
│      │    query_device_status            │      │
│      │                                   │      │
│ 设备 │ ──────────────────────────────→  │      │  步骤4: 设备立即采集并上报状态
│      │    device_status_report           │      │
└──────┘                                   └──────┘
```

| 步骤 | 接口 | 预期 |
|------|------|------|
| 步骤1 | `GET /device/listen/{id}?timeout=15` | 设备监听线程启动，连接保持 |
| 步骤2 | `POST /device/query-status` | code=0, **delivery_method=long_polling** |
| 步骤3 | 设备端 `/listen` 返回 | has_command=true, msg_type=query_device_status |
| 步骤4 | `POST /device/report` | code=0, 设备状态更新成功 |

**实际测试结果：**
```
✅ PASS | T7: 长轮询实时查询
ℹ️  监听✅、下发realtime✅、实时收到✅、上报响应✅
```

> 💡 测试脚本使用 `threading.Thread` 模拟设备端长轮询监听，验证命令实时到达。

---

#### T8: 后台主动查询 - 离线回退流程 (心跳携带) ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备不在线时，命令回退到排队，心跳时自动获取 |
| **场景** | 设备无活跃的长轮询连接（离线），后台回退到 pending_command 机制 |

**离线回退流程:**
1. 下发 query_device_status（设备不在线）→ delivery_method=queued
2. 设备发送心跳 → 心跳响应中自动携带排队的命令

**预期响应（步骤2 - 心跳）:**

```
HTTP 200
{
  "code": 0,
  "data": {
    "ack": { ... },                       ← ✅ 存在
    "time_sync": { ... },                 ← ✅ 存在（心跳触发）
    "command": {                           ← ✅ 存在（排队的命令随心跳下发）
      "msg_type": "query_device_status",
      "device_id": "DEV001",
      ...
    }
  }
}
```

| 验证项 | 预期 | 说明 |
|--------|------|------|
| 步骤1: delivery_method | **queued** | 设备不在线，命令排队 |
| data.ack | 存在 | |
| data.time_sync | 存在 | 心跳触发 |
| data.command | **存在** | 排队的 query_device_status 随心跳下发 |
| command.msg_type | query_device_status | |

**实际测试结果：**
```
✅ PASS | T8: 离线回退(心跳携带)
```

---

#### T9: 管理后台主动查询 (admin API)

| 项目 | 内容 |
|------|------|
| **目的** | 验证管理员通过后台管理系统触发查询，获取实时/离线反馈 |
| **接口** | `POST /api/v1/admin/device/query-status` |
| **认证** | 需要管理员 JWT token |
| **前端入口** | 设备列表页「查询」按钮 / 设备详情页「主动查询设备状态」按钮 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| admin 登录 | 获取 JWT token | |
| HTTP 状态码 | 200 | |
| code | 0 | 命令下发成功 |
| delivery_method | `websocket`、`long_polling` 或 `queued` | 三种投递方式 |
| 前端反馈 | WS在线: "命令已通过WebSocket实时下发" / LP在线: "命令已通过长轮询实时下发" / 离线: "命令已排队" | 根据 delivery_method 区分提示 |

**实际测试结果：**
```
✅ PASS | T9: 管理后台主动查询
```

---

#### T10: 错误校验码上报

| 项目 | 内容 |
|------|------|
| **目的** | 验证校验码不匹配时的拒绝处理 |
| **接口** | `POST /api/v1/device/report` |
| **发送数据** | 正常报文但 check_code 被篡改 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| code | 1 | 校验失败 |
| ack.data.ack_code | 1 | 接收失败 |
| ack.data.ack_desc | 包含"校验" | 失败原因描述 |

**实际测试结果：**
```
✅ PASS | T10: 错误校验码上报
```

---

#### T11: 小程序扫码上报 (演示)

| 项目 | 内容 |
|------|------|
| **目的** | 展示扫码报文格式（需要用户token，仅演示） |
| **接口** | `POST /api/v1/device/qrcode-report` |
| **认证** | 需要小程序用户 token |
| **说明** | 此测试仅展示报文结构，不做实际调用 |

**实际测试结果：**
```
✅ PASS | T11: 扫码上报(报文格式演示)
ℹ️  仅格式演示，未实际调用
```

---

## 3. 协议功能覆盖矩阵

| 协议功能 | WebSocket 测试 | HTTP 测试 | 说明 |
|----------|----------------|-----------|------|
| device_status_report | **T14, T15, T16** | T1~T5 | HTTP+WS 全覆盖：首次/非首次/告警/摄像头 |
| heartbeat_report | **T12** | T6, T8 | HTTP+WS 心跳(无命令/有命令/WS心跳) |
| server_ack | **T12~T17** | T1~T10 | HTTP+WS 两条通道均验证应答 |
| time_sync (首次上报) | **T14** | T1 | HTTP+WS 均验证 first_report_at=NULL 触发 |
| time_sync (心跳) | **T12** | T6, T8 | HTTP+WS 均验证心跳触发时间同步 |
| WebSocket 长连接 | **T12~T17** | — | ⭐ 心跳/上报/命令/校验 全部通过 WS 验证 |
| WebSocket 命令推送 | **T13** | — | ⭐ 通过 WS 实时推送 query_device_status |
| query_device_status (WS) | **T13** | — | WebSocket 实时推送（优先级最高） |
| query_device_status (LP) | — | **T7** | 长轮询 + asyncio.Queue 实时推送 |
| query_device_status (离线) | — | **T8** | 命令排队 + 心跳获取（向下兼容） |
| query_device_status (admin) | — | T9 | 管理后台触发，返回 delivery_method |
| 长轮询监听 | — | **T7** | GET /device/listen/{id} |
| pending_command (回退) | — | T8 | 离线排队 → 心跳获取 → 清除 |
| camera_data (Base64图片) | **T15, T16** | P1, T2~T4 | HTTP+WS 均验证摄像头数据存储 |
| MD5 校验码 | **T17** | P2, T10 | HTTP+WS 均验证校验码拒绝 |
| 管理后台集成 | — | T9 | admin API 认证调用 |

---

## 4. time_sync 触发条件汇总

| 场景 | 触发? | WebSocket 测试 | HTTP 测试 | 说明 |
|------|-------|----------------|-----------|------|
| 设备首次上报 (first_report_at=NULL) | ✅ **触发** | **T14** | T1 | 协议规定：首次上报数据时下发时间同步 |
| 非首次上报 (first_report_at≠NULL) | ❌ 不触发 | **T15, T16** | T2~T5 | first_report_at 已有值，非首次 |
| 心跳上报 | ✅ **触发** | **T12** | T6, T8 | 协议规定：收到心跳后下发时间同步 |

> **重要说明**：`is_using` 字段（0=空闲, 1=使用中）仅用于表示设备当前状态，**不参与首次上报的判断**。
> 首次上报判断完全依赖 `devices.first_report_at` 字段是否为 NULL。

---

## 5. 测试输出示例

运行全部测试后，脚本会自动输出汇总表格：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  📊 测试结果汇总
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  总计: 19 | ✅ 通过: 18 | ❌ 失败: 1
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  编号     测试名称                           结果       说明
  ────── ────────────────────────────── ──────── ────────────────────
  P1     Base64 PNG 图片生成                ✅ PASS   4 张图片全部验证通过
  P2     MD5 校验码验证                      ✅ PASS   
  T12    WebSocket 心跳 ⭐                   ✅ PASS   同步时间: 2026-02-08 22:17:56
  T13    WebSocket 命令推送 ⭐               ✅ PASS   WS连接✅、下发websocket✅、WS收到命令✅
  T14    WS 首次上报 ⭐⭐                    ❌ FAIL   设备已上报过数据，需重置 first_report_at
  T15    WS 状态上报(含摄像头) ⭐⭐          ✅ PASS   
  T16    WS 烟感告警上报 ⭐⭐                ✅ PASS   
  T17    WS 错误校验码 ⭐⭐                  ✅ PASS   
  T1     首次上报时间同步                       ✅ PASS   同步时间: 2026-02-08 22:17:54
  T2     非首次上报(含摄像头)                    ✅ PASS   
  T3     持续使用上报(含摄像头)                   ✅ PASS   
  T4     烟感告警上报(含现场照片)                  ✅ PASS   
  T5     使用结束上报                         ✅ PASS   
  T6     心跳上报(time_sync)                ✅ PASS   同步时间: 2026-02-08 22:17:55
  T7     长轮询实时查询                        ✅ PASS   监听✅、下发realtime✅、实时收到✅、上报响应✅
  T8     离线回退(心跳携带)                     ✅ PASS   
  T9     管理后台主动查询                       ✅ PASS   
  T10    错误校验码上报                        ✅ PASS   
  T11    扫码上报(报文格式演示)                   ✅ PASS   仅格式演示，未实际调用

  ⚠️  有 1 个测试未通过，请检查后端服务和数据库。
```

---

## 6. 管理后台验证步骤

测试脚本运行后，需在管理后台进行人工验证：

1. **登录管理后台** → 设备管理
2. 在设备列表中找到 `DEV001`，观察：
   - 电池电量、烟感状态、仓体状态等是否与最后一次上报一致
   - **「连接」列**显示设备当前连接类型：WebSocket / 长轮询 / 离线
   - 点击操作列的「查询」按钮：
     - WebSocket 在线：提示 ✅「查询命令已通过 WebSocket 实时下发到设备」，3秒后自动刷新
     - 长轮询在线：提示 ✅「查询命令已通过长轮询实时下发到设备」，3秒后自动刷新
     - 设备离线：提示 ⚠️「设备当前不在线，命令已排队」
3. 点击「详情」进入设备详情页：
   - 页面顶部显示设备**连接类型标签**（WebSocket/长轮询/离线）
   - 查看 6 张实时状态卡片是否与上报数据一致
   - 查看「摄像头画面」区域，应显示最近上报的测试图片
   - 点击图片可放大预览
   - 点击「查看历史记录」查看所有上报批次
4. 点击「主动查询设备状态」按钮：
   - WebSocket 在线：提示「命令已通过 WebSocket 实时下发到设备」，3秒后自动刷新
   - 长轮询在线：提示「命令已通过长轮询实时下发到设备」，3秒后自动刷新
   - 设备离线：提示「设备当前不在线，命令已排队，设备上线后将自动响应」
5. **设备统计**（仪表盘或设备统计 API）：
   - 应包含 `websocket_online_count`（WebSocket 在线设备数）

---

## 7. 数据库字段说明

### devices 表关键字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `first_report_at` | DateTime, nullable | 首次上报时间。NULL=从未上报，用于判断是否触发 time_sync |
| `is_using` | Integer | 设备是否有人使用(0=空闲, 1=使用中)。**不参与首次上报判断** |
| `pending_command` | Text, nullable | 待执行命令(JSON)。设备离线时排队，心跳或轮询时获取并清除；设备在线时通过长轮询实时推送 |
| `pending_command_at` | DateTime, nullable | 命令排队时间 |

---

## 8. 常见问题

| 问题 | 原因 | 解决 |
|------|------|------|
| **T12~T17 跳过** | **`websockets` 库未安装** | **执行 `pip install websockets`** |
| **T13 delivery_method≠websocket** | **WebSocket 连接未建立或已断开** | **确保 T13 中 WebSocket 连接已建立再下发命令** |
| **T14 未收到 time_sync** | **设备 `first_report_at` 已有值** | 执行 `UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';`（与 T1 同理） |
| **T15 意外收到 time_sync** | **T14 未执行或 first_report_at 仍为 NULL** | 确保 T14 先于 T15 执行 |
| **T17 ack_code≠1** | **WebSocket 端校验逻辑异常** | 检查 WebSocket handler 中 `process_device_status_report` 的校验流程 |
| T1~T11 全部失败 | 后端服务未启动 | 检查 Docker 容器是否运行 |
| T1 未返回 time_sync | 设备 `first_report_at` 已有值 | 执行 `UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';` |
| T2 意外返回 time_sync | T1 未执行或设备 first_report_at 仍为 NULL | 确保 T1 先于 T2 执行 |
| T7 delivery_method≠long_polling | 设备监听线程未就绪 | 检查 `/device/listen` 端点是否正常；增加监听等待时间 |
| T7 设备端未收到命令 | 长轮询连接超时或被中断 | 检查网络连接和超时配置 |
| T8 command 为空 | 命令被 T7 取走或 delivery 为非queued | 确保 T8 运行时设备无活跃监听（T7 已完成） |
| T9 admin 登录失败 | 管理员账号未创建 | 执行 `docker exec -it clothing-recycle-api python scripts/create_admin.py` |
| T10 未返回 ack_code=1 | 后端未实现校验拒绝 | 检查 `device_communication.py` 中的校验逻辑 |
| 数据库缺少 first_report_at 列 | 数据库未更新 | 执行 `ALTER TABLE devices ADD COLUMN first_report_at DATETIME NULL COMMENT '首次上报时间';` |
