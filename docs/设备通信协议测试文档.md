# 4G设备-后台通信协议 · 完整测试文档

## 1. 概述

本文档描述旧物回收系统中 **4G设备与后台服务** 之间通信协议的完整测试方案。测试脚本位于 `backend/scripts/test_heartbeat.py`。

### 1.1 测试目标

验证《旧物回收通信协议.docx》中定义的所有消息类型和交互流程：

| 方向 | 消息类型 | 说明 |
|------|----------|------|
| 设备→后台 | `device_status_report` | 设备状态上报（含传感器+摄像头） |
| 设备→后台 | `heartbeat_report` | 心跳包上报 |
| 后台→设备 | `server_ack` | 服务器应答 |
| 后台→设备 | `time_sync` | 时间同步消息 |
| 后台→设备 | `query_device_status` | 主动查询设备状态 |

### 1.2 "首次上报"判断逻辑

后台通过 `devices` 表的 **`first_report_at`** 字段判断设备是否首次上报数据：

| `first_report_at` 值 | 含义 | time_sync 触发 |
|----------------------|------|----------------|
| `NULL` | 设备从未上报过数据，视为首次上报 | ✅ 触发 |
| 非 `NULL` (有时间戳) | 设备已上报过数据，非首次上报 | ❌ 不触发 |

> **注意**：`is_using` 字段仅表示设备当前是否有人使用，**与首次上报判断无关**。

### 1.3 运行方式

```bash
# 全部测试（需要后端服务运行）
python3 backend/scripts/test_heartbeat.py

# 仅离线测试（不需要后端服务）
python3 backend/scripts/test_heartbeat.py --offline-only

# 指定 API 地址
python3 backend/scripts/test_heartbeat.py --api http://localhost:8000/api/v1
```

### 1.4 配置项

| 配置 | 默认值 | 说明 |
|------|--------|------|
| `API_BASE_URL` | `http://42.194.134.223:8000/api/v1` | 后端API地址 |
| `DEVICE_ID` | `DEV001` | 测试设备ID |
| `ADMIN_USERNAME` | `admin` | 管理员账号 |
| `ADMIN_PASSWORD` | `admin123` | 管理员密码 |

### 1.5 测试前准备

为确保 T1（首次上报）测试能正确验证 `time_sync` 触发，需要重置设备的 `first_report_at` 字段：

```sql
-- 在 MySQL 中执行
UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';
```

---

## 2. 测试用例详细说明

### 2.1 离线测试

#### P1: Base64 PNG 图片生成验证

| 项目 | 内容 |
|------|------|
| **目的** | 验证纯Python生成的PNG图片是否合法 |
| **前置条件** | 无（不需要网络） |
| **测试步骤** | 生成4种不同颜色的PNG图片，验证格式 |
| **验证项** | ① PNG头部签名(89 50 4E 47) ② Base64编码以 `iVBOR` 开头 |
| **预期结果** | 4张图片全部通过PNG格式验证 |

#### P2: MD5 校验码计算与验证

| 项目 | 内容 |
|------|------|
| **目的** | 验证MD5校验码算法实现正确 |
| **前置条件** | 无 |
| **校验规则** | `MD5(包头 + JSON数据体(不含check_code))`，32位小写 |
| **验证项** | ① 正确校验码匹配 ② 错误校验码不匹配 ③ 包头参与校验（有包头和无包头结果不同） |
| **预期结果** | 3个场景全部验证通过 |

---

### 2.2 在线测试

#### T1: 首次上报 → 触发时间同步 (first_report_at=NULL) ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备首次向后台上报数据时，后台返回 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **协议规定** | 设备首次上报数据时（`first_report_at` 为 NULL），除了返回 ack 消息，还需返回 time_sync 消息 |
| **前置条件** | 设备 `first_report_at` 字段为 NULL |
| **发送数据** | `msg_type=device_status_report`, `is_using=0`, `battery=85` |

**预期响应:**

```
HTTP 200
{
  "code": 0,
  "data": {
    "ack": { ... server_ack ... },       ← ✅ 存在
    "time_sync": {                        ← ✅ 存在（首次上报触发）
      "msg_type": "time_sync",
      "device_id": "DEV001",
      "data": {
        "standard_time": "2026-02-08 14:30:00"  ← 当前服务器时间
      }
    }
  }
}
```

| 验证项 | 预期 | 说明 |
|--------|------|------|
| HTTP 状态码 | 200 | |
| code | 0 | 处理成功 |
| data.ack | 存在 | 服务器应答 |
| data.time_sync | **存在** | first_report_at 为 NULL，触发时间同步 |
| time_sync.data.standard_time | 当前服务器时间 | 用于设备校时 |

> ⚠️ 如果测试结果中 time_sync 未出现，说明设备之前已上报过数据。请执行以下 SQL 后重新测试：
> ```sql
> UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';
> ```

---

#### T2: 非首次上报 (含摄像头)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备已上报过数据后，后续上报不再触发 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **前置条件** | 设备 `first_report_at` 已有值（由 T1 设置） |
| **发送数据** | `is_using=1`, 含 camera_1×3 + camera_2×3 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **不存在** | first_report_at 已有值，非首次上报 |
| 摄像头图片 | 保存到数据库 | camera_1×3 + camera_2×3 |

---

#### T3: 持续使用上报 (is_using=1, 含摄像头)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备持续使用中的上报，非首次不触发 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **前置条件** | 设备 `first_report_at` 已有值 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **不存在** | 非首次上报，不触发 |
| 摄像头图片 | 保存到数据库 | 新的一批图片 |

---

#### T4: 烟感告警上报 (smoke_sensor_status=1, 含告警照片)

| 项目 | 内容 |
|------|------|
| **目的** | 验证烟感告警时的状态上报和图片保存 |
| **接口** | `POST /api/v1/device/report` |
| **发送数据** | `smoke_sensor_status=1`, camera_1×2 (红色调告警场景), camera_2×1 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| ack.data.ack_code | 0 | 接收成功 |
| 后台设备表 | smoke_sensor_status=1 | 告警状态被更新 |
| 管理后台 | 显示烟感告警标红 | 仪表盘告警计数+1 |

---

#### T5: 使用结束上报 (is_using: 1→0)

| 项目 | 内容 |
|------|------|
| **目的** | 验证设备使用结束恢复空闲时不触发 time_sync |
| **接口** | `POST /api/v1/device/report` |
| **协议说明** | time_sync 仅在首次上报和心跳时触发 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **不存在** | 非首次上报，不触发时间同步 |

---

#### T6: 心跳上报 (无待执行命令) ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证心跳上报后，后台下发时间同步 |
| **接口** | `POST /api/v1/device/heartbeat` |
| **协议规定** | 后台收到设备心跳包后，下发 time_sync 消息 |

**预期响应:**

```
HTTP 200
{
  "code": 0,
  "data": {
    "ack": { ... },                       ← ✅ 存在
    "time_sync": {                        ← ✅ 存在（心跳触发时间同步）
      "data": {
        "standard_time": "2026-02-08 14:35:00"
      }
    }
    // 无 command                          ← ✅ 不存在（无待执行命令）
  }
}
```

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | **存在** | 心跳触发时间同步 |
| data.command | **不存在** | 无待执行命令 |

---

#### T7: 后台主动查询设备状态 (完整流程) ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证 query_device_status 从命令下发到设备响应的完整流程 |
| **协议规定** | 后台主动下发 query_device_status，设备收到后返回 device_status_report |

**完整流程:**

```
┌──────┐    步骤1: POST /query-status     ┌──────┐
│ 后台 │ ──────────────────────────────→  │ DB   │  命令保存到 pending_command
│      │                                  │      │
│      │    步骤2: GET /pending-commands   │      │
│      │ ←────────────────────────────── │      │  设备轮询获取命令
│      │                                  │      │
│      │    步骤3: GET /pending-commands   │      │
│      │ ←────────────────────────────── │      │  再次轮询→空（已取走）
│      │                                  │      │
│      │    步骤4: POST /report            │      │
│ 设备 │ ──────────────────────────────→  │      │  设备上报全量状态
└──────┘                                  └──────┘
```

| 步骤 | 接口 | 预期 |
|------|------|------|
| 步骤1 | `POST /device/query-status` | code=0, 命令已排队 |
| 步骤2 | `GET /device/pending-commands/{id}` | has_command=true, msg_type=query_device_status |
| 步骤3 | `GET /device/pending-commands/{id}` | has_command=false (已被取走，不重复下发) |
| 步骤4 | `POST /device/report` | code=0, 设备状态更新成功 |

---

#### T8: 心跳携带待执行命令 ⭐

| 项目 | 内容 |
|------|------|
| **目的** | 验证心跳响应中自动携带待执行命令 |
| **协议规定** | 设备心跳时，后台检查是否有待执行命令，有则一并下发 |

**步骤:**
1. 排队 query_device_status 命令
2. 设备发送心跳

**预期响应（步骤2）:**

```
HTTP 200
{
  "code": 0,
  "data": {
    "ack": { ... },                       ← ✅ 存在
    "time_sync": { ... },                 ← ✅ 存在（心跳触发）
    "command": {                           ← ✅ 存在（待执行命令）
      "msg_type": "query_device_status",
      "device_id": "DEV001",
      ...
    }
  }
}
```

| 验证项 | 预期 | 说明 |
|--------|------|------|
| data.ack | 存在 | |
| data.time_sync | 存在 | 心跳触发 |
| data.command | **存在** | 排队的 query_device_status |
| command.msg_type | query_device_status | |

---

#### T9: 管理后台主动查询 (admin API)

| 项目 | 内容 |
|------|------|
| **目的** | 验证管理员通过后台管理系统触发查询 |
| **接口** | `POST /api/v1/admin/device/query-status` |
| **认证** | 需要管理员 JWT token |
| **前端入口** | 设备列表页「查询」按钮 / 设备详情页「主动查询设备状态」按钮 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| admin 登录 | 获取 JWT token | |
| HTTP 状态码 | 200 | |
| code | 0 | 命令排队成功 |
| 后续 | 设备下次心跳时获取命令 | |

---

#### T10: 错误校验码上报

| 项目 | 内容 |
|------|------|
| **目的** | 验证校验码不匹配时的拒绝处理 |
| **接口** | `POST /api/v1/device/report` |
| **发送数据** | 正常报文但 check_code 被篡改 |

| 验证项 | 预期 | 说明 |
|--------|------|------|
| code | 1 | 校验失败 |
| ack.data.ack_code | 1 | 接收失败 |
| ack.data.ack_desc | 包含"校验" | 失败原因描述 |

---

#### T11: 小程序扫码上报 (演示)

| 项目 | 内容 |
|------|------|
| **目的** | 展示扫码报文格式（需要用户token，仅演示） |
| **接口** | `POST /api/v1/device/qrcode-report` |
| **认证** | 需要小程序用户 token |
| **说明** | 此测试仅展示报文结构，不做实际调用 |

---

## 3. 协议功能覆盖矩阵

| 协议功能 | 测试覆盖 | 说明 |
|----------|----------|------|
| device_status_report | T1, T2, T3, T4, T5 | 首次上报/非首次/持续使用/告警/结束 |
| heartbeat_report | T6, T8 | 无命令/有命令 |
| server_ack | T1~T10 | 所有上报接口均返回 |
| time_sync (首次上报) | T1 | **first_report_at 为 NULL 时触发** |
| time_sync (心跳) | T6, T8 | 收到心跳后触发 |
| query_device_status | T7, T8, T9 | 轮询方式/心跳方式/管理后台 |
| pending_command | T7, T8 | 排队→获取→清除 |
| camera_data (Base64图片) | P1, T2, T3, T4 | 生成/上传/存储 |
| MD5 校验码 | P2, T10 | 计算/验证/拒绝 |
| 管理后台集成 | T9 | admin API 认证调用 |

---

## 4. time_sync 触发条件汇总

| 场景 | 触发? | 测试 | 说明 |
|------|-------|------|------|
| 设备首次上报 (first_report_at=NULL) | ✅ **触发** | T1 | 协议规定：首次上报数据时下发时间同步 |
| 非首次上报 (first_report_at≠NULL) | ❌ 不触发 | T2, T3, T4, T5 | first_report_at 已有值，非首次 |
| 心跳上报 | ✅ **触发** | T6, T8 | 协议规定：收到心跳后下发时间同步 |

> **重要说明**：`is_using` 字段（0=空闲, 1=使用中）仅用于表示设备当前状态，**不参与首次上报的判断**。
> 首次上报判断完全依赖 `devices.first_report_at` 字段是否为 NULL。

---

## 5. 测试输出示例

运行全部测试后，脚本会自动输出汇总表格：

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  📊 测试结果汇总
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  总计: 13 | ✅ 通过: 13 | ❌ 失败: 0
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  编号   测试名称                         结果     说明
  ────── ────────────────────────────── ──────── ──────────────
  P1     Base64 PNG 图片生成             ✅ PASS  4张图片全部通过
  P2     MD5 校验码验证                  ✅ PASS
  T1     首次上报时间同步                 ✅ PASS  同步时间: 2026-02-08 14:30:00
  T2     非首次上报(含摄像头)             ✅ PASS
  T3     持续使用上报(含摄像头)           ✅ PASS
  T4     烟感告警上报(含现场照片)         ✅ PASS
  T5     使用结束上报                     ✅ PASS
  T6     心跳上报(time_sync)             ✅ PASS  同步时间: 2026-02-08 14:35:00
  T7     后台主动查询(完整流程)           ✅ PASS  步骤1✅、步骤2✅、步骤3✅、步骤4✅
  T8     心跳携带待执行命令               ✅ PASS
  T9     管理后台主动查询                 ✅ PASS
  T10    错误校验码上报                   ✅ PASS
  T11    扫码上报(报文格式演示)           ✅ PASS  仅格式演示
```

---

## 6. 管理后台验证步骤

测试脚本运行后，需在管理后台进行人工验证：

1. **登录管理后台** → 设备管理
2. 在设备列表中找到 `DEV001`，观察：
   - 电池电量、烟感状态、仓体状态等是否与最后一次上报一致
   - 点击操作列的「查询」按钮，验证提示"查询指令已下发"
3. 点击「详情」进入设备详情页：
   - 查看 6 张实时状态卡片是否与上报数据一致
   - 查看「摄像头画面」区域，应显示最近上报的测试图片
   - 点击图片可放大预览
   - 点击「查看历史记录」查看所有上报批次
4. 点击「主动查询设备状态」按钮：
   - 预期提示"查询指令已下发，设备将在下次心跳时上报最新状态"
   - 5秒后页面自动刷新

---

## 7. 数据库字段说明

### devices 表关键字段

| 字段 | 类型 | 说明 |
|------|------|------|
| `first_report_at` | DateTime, nullable | 首次上报时间。NULL=从未上报，用于判断是否触发 time_sync |
| `is_using` | Integer | 设备是否有人使用(0=空闲, 1=使用中)。**不参与首次上报判断** |
| `pending_command` | Text, nullable | 待执行命令(JSON)。设备心跳或轮询时获取并清除 |
| `pending_command_at` | DateTime, nullable | 命令排队时间 |

---

## 8. 常见问题

| 问题 | 原因 | 解决 |
|------|------|------|
| T1~T8 全部失败 | 后端服务未启动 | 检查 Docker 容器是否运行 |
| T1 未返回 time_sync | 设备 `first_report_at` 已有值 | 执行 `UPDATE devices SET first_report_at = NULL WHERE device_id = 'DEV001';` |
| T2 意外返回 time_sync | T1 未执行或设备 first_report_at 仍为 NULL | 确保 T1 先于 T2 执行 |
| T7 步骤1 失败 (404) | 路由未注册 | 检查 `device_communication.py` 中 query-status 端点 |
| T8 command 为空 | 命令被 T7 取走 | 确保 T7 和 T8 按顺序执行（T7会清除命令） |
| T9 admin 登录失败 | 管理员账号未创建 | 执行 `docker exec -it clothing-recycle-api python scripts/create_admin.py` |
| T10 未返回 ack_code=1 | 后端未实现校验拒绝 | 检查 `device_communication.py` 中的校验逻辑 |
| 数据库缺少 first_report_at 列 | 数据库未更新 | 执行 `ALTER TABLE devices ADD COLUMN first_report_at DATETIME NULL COMMENT '首次上报时间';` |
