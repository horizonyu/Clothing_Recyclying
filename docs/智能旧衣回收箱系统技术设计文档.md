# 智能旧衣回收箱系统技术设计文档

**版本：** V1.0  
**创建日期：** 2026年1月2日  
**文档状态：** 初稿  
**关联文档：** 智能旧衣回收箱系统需求设计文档.md

---

## 目录

1. [概述](#1-概述)
2. [系统架构设计](#2-系统架构设计)
3. [技术栈选型](#3-技术栈选型)
4. [后端服务设计](#4-后端服务设计)
5. [硬件通信设计](#5-硬件通信设计)
6. [小程序设计](#6-小程序设计)
7. [后台管理系统设计](#7-后台管理系统设计)
8. [数据库详细设计](#8-数据库详细设计)
9. [缓存设计](#9-缓存设计)
10. [安全设计](#10-安全设计)
11. [部署架构](#11-部署架构)
12. [项目代码结构](#12-项目代码结构)

---

## 1. 概述

### 1.1 文档目的

本文档是智能旧衣回收箱系统的技术设计文档，详细描述系统的技术架构、模块设计、接口规范、数据库设计等技术实现细节，为开发团队提供技术指导。

### 1.2 系统边界

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              系统边界                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐ │
│   │  硬件设备    │    │ 用户小程序  │    │  后台管理   │    │  后端服务   │ │
│   │  (自研)     │    │ (微信/支付宝)│    │  (Web)     │    │  (云端)    │ │
│   └─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘ │
│                                                                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                             外部依赖                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│   • 微信开放平台 (小程序登录、支付、消息推送)                                  │
│   • 支付宝开放平台 (小程序登录、支付)                                         │
│   • 阿里云服务 (OSS、短信、实名认证)                                          │
│   • EMQX Cloud (MQTT消息服务)                                               │
│   • 高德/腾讯地图 (LBS定位)                                                  │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## 2. 系统架构设计

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                    接入层                                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌────────────────────────┐  │
│  │ 微信小程序    │  │ 支付宝小程序  │  │ 管理后台Web  │  │    IoT设备 (MQTT)      │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  └────────────────────────┘  │
└────────────────────────────────────────┬────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                   网关层                                            │
│  ┌──────────────────────────────────────────────────────────────────────────────┐  │
│  │                          Nginx (负载均衡/SSL终止)                              │  │
│  └──────────────────────────────────────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────────────────────────────────────┐  │
│  │                    API Gateway (认证/限流/路由/日志)                           │  │
│  └──────────────────────────────────────────────────────────────────────────────┘  │
└────────────────────────────────────────┬────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                  业务服务层                                          │
│                                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                │
│  │ 用户服务     │  │ 订单服务     │  │ 设备服务     │  │ 支付服务     │                │
│  │ user-svc    │  │ order-svc   │  │ device-svc  │  │ payment-svc │                │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘                │
│                                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                │
│  │ 通知服务     │  │ 统计服务     │  │ AI服务       │  │ 文件服务     │                │
│  │ notify-svc  │  │ stats-svc   │  │ ai-svc      │  │ file-svc    │                │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘                │
│                                                                                     │
└────────────────────────────────────────┬────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                   数据层                                            │
│                                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                │
│  │   MySQL     │  │   Redis     │  │  MongoDB    │  │  OSS存储    │                │
│  │  (主从)     │  │  (集群)     │  │  (副本集)   │  │             │                │
│  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘                │
│                                                                                     │
└────────────────────────────────────────┬────────────────────────────────────────────┘
                                         │
                                         ▼
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                                 消息/IoT层                                          │
│                                                                                     │
│  ┌──────────────────────────┐  ┌──────────────────────────────────────────────┐    │
│  │   RabbitMQ (消息队列)     │  │        EMQX (MQTT Broker)                    │    │
│  └──────────────────────────┘  └──────────────────────────────────────────────┘    │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 2.2 服务划分

| 服务名称 | 职责 | 端口 | 技术栈 |
|---------|-----|------|-------|
| api-gateway | API网关，认证鉴权、限流、路由 | 8000 | Python/FastAPI |
| user-svc | 用户管理、登录认证、实名认证 | 8001 | Python/FastAPI |
| order-svc | 订单管理、投递记录、金额计算 | 8002 | Python/FastAPI |
| device-svc | 设备管理、状态监控、心跳处理 | 8003 | Python/FastAPI |
| payment-svc | 支付处理、提现、对账 | 8004 | Python/FastAPI |
| notify-svc | 消息推送、短信、模板消息 | 8005 | Python/FastAPI |
| stats-svc | 数据统计、报表生成 | 8006 | Python/FastAPI |
| ai-svc | AI图像识别、衣物分类 | 8007 | Python/FastAPI |
| file-svc | 文件上传、图片处理 | 8008 | Python/FastAPI |
| mqtt-bridge | MQTT消息桥接处理 | 8009 | Python |

### 2.3 服务间通信

```
┌─────────────────────────────────────────────────────────────────────┐
│                        服务间通信方式                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  同步调用 (HTTP/gRPC)                                               │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  api-gateway ──HTTP──► user-svc ──HTTP──► order-svc          │  │
│  │       │                    │                                  │  │
│  │       └────────HTTP────────┴──────────► payment-svc          │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  异步消息 (RabbitMQ)                                                │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  order-svc ──publish──► [order.created] ──consume──► notify  │  │
│  │  device-svc ──publish──► [device.alarm] ──consume──► notify  │  │
│  │  payment-svc ──publish──► [withdraw.success] ──consume──► notify │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
│  IoT通信 (MQTT)                                                     │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │  设备 ──MQTT──► EMQX ──webhook──► mqtt-bridge ──► device-svc │  │
│  └──────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 3. 技术栈选型

### 3.1 后端技术栈

| 类别 | 技术选型 | 版本 | 选型理由 |
|-----|---------|------|---------|
| 语言 | Python | 3.11+ | 开发效率高，生态丰富，AI库支持好 |
| Web框架 | FastAPI | 0.109+ | 高性能，自动文档，类型提示 |
| ORM | SQLAlchemy | 2.0+ | 功能强大，支持异步 |
| 数据验证 | Pydantic | 2.5+ | 类型安全，与FastAPI集成 |
| 任务队列 | Celery | 5.3+ | 成熟稳定，功能丰富 |
| 消息队列 | RabbitMQ | 3.12+ | 可靠性高，支持多种协议 |

### 3.2 数据存储

| 类别 | 技术选型 | 版本 | 用途 |
|-----|---------|------|------|
| 关系数据库 | MySQL | 8.0+ | 核心业务数据 |
| 缓存 | Redis | 7.0+ | 会话、热点数据、分布式锁 |
| 文档数据库 | MongoDB | 6.0+ | 日志、设备数据、统计数据 |
| 对象存储 | 阿里云OSS | - | 图片、视频文件 |

### 3.3 IoT技术栈

| 类别 | 技术选型 | 版本 | 说明 |
|-----|---------|------|------|
| MQTT Broker | EMQX | 5.0+ | 企业级MQTT消息服务器 |
| 协议 | MQTT 3.1.1/5.0 | - | 轻量级IoT通信协议 |
| 设备认证 | 证书+密钥 | - | TLS双向认证 |

### 3.4 前端技术栈

| 平台 | 技术选型 | 说明 |
|-----|---------|------|
| 用户小程序 | 微信原生/Taro | 支持微信+支付宝双端 |
| 管理后台 | Vue3 + Element Plus | 响应式管理界面 |
| 图表库 | ECharts | 数据可视化 |

---

## 4. 后端服务设计

### 4.1 用户服务 (user-svc)

#### 4.1.1 模块职责

- 用户注册、登录、登出
- 微信/支付宝OAuth认证
- 用户信息管理
- 实名认证
- 用户钱包管理

#### 4.1.2 核心类设计

```python
# models/user.py
from sqlalchemy import Column, String, Integer, DateTime, DECIMAL
from sqlalchemy.orm import declarative_base

Base = declarative_base()

class User(Base):
    """用户模型"""
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(String(32), unique=True, nullable=False, index=True)
    phone = Column(String(20), index=True)
    nickname = Column(String(50))
    avatar_url = Column(String(255))
    openid_wechat = Column(String(64), index=True)
    openid_alipay = Column(String(64), index=True)
    real_name = Column(String(50))
    id_card_encrypted = Column(String(255))  # AES加密存储
    is_verified = Column(Integer, default=0)
    status = Column(Integer, default=1)
    created_at = Column(DateTime)
    updated_at = Column(DateTime)


class UserWallet(Base):
    """用户钱包模型"""
    __tablename__ = "user_wallets"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(String(32), unique=True, nullable=False)
    balance = Column(DECIMAL(12, 2), default=0)
    frozen_balance = Column(DECIMAL(12, 2), default=0)
    total_income = Column(DECIMAL(12, 2), default=0)
    total_withdraw = Column(DECIMAL(12, 2), default=0)
    version = Column(Integer, default=0)  # 乐观锁
```

```python
# services/user_service.py
from typing import Optional
from datetime import datetime, timedelta
import jwt
from passlib.context import CryptContext

class UserService:
    """用户服务"""
    
    def __init__(self, db_session, redis_client, config):
        self.db = db_session
        self.redis = redis_client
        self.config = config
        self.pwd_context = CryptContext(schemes=["bcrypt"])
    
    async def login_by_wechat(self, code: str) -> dict:
        """微信登录"""
        # 1. 通过code换取openid和session_key
        wechat_info = await self._get_wechat_openid(code)
        openid = wechat_info["openid"]
        
        # 2. 查询或创建用户
        user = await self._get_or_create_user_by_openid(openid, "wechat")
        
        # 3. 生成JWT token
        token = self._generate_token(user.user_id)
        
        # 4. 缓存用户会话
        await self._cache_user_session(user.user_id, token)
        
        return {
            "user_id": user.user_id,
            "token": token,
            "is_new_user": user.is_new,
            "is_verified": user.is_verified
        }
    
    async def verify_identity(self, user_id: str, real_name: str, id_card: str) -> bool:
        """实名认证"""
        # 1. 调用第三方实名认证接口
        verify_result = await self._call_identity_verify_api(real_name, id_card)
        
        if not verify_result["success"]:
            raise BusinessException("实名认证失败")
        
        # 2. 加密存储身份证号
        encrypted_id_card = self._encrypt_id_card(id_card)
        
        # 3. 更新用户信息
        await self._update_user_verification(user_id, real_name, encrypted_id_card)
        
        return True
    
    async def get_wallet_balance(self, user_id: str) -> dict:
        """获取钱包余额"""
        wallet = await self.db.query(UserWallet).filter_by(user_id=user_id).first()
        return {
            "balance": float(wallet.balance),
            "frozen_balance": float(wallet.frozen_balance),
            "total_income": float(wallet.total_income),
            "total_withdraw": float(wallet.total_withdraw)
        }
    
    async def add_balance(self, user_id: str, amount: float, order_id: str) -> bool:
        """增加余额（使用乐观锁）"""
        max_retries = 3
        for _ in range(max_retries):
            wallet = await self.db.query(UserWallet).filter_by(user_id=user_id).first()
            old_version = wallet.version
            
            wallet.balance += amount
            wallet.total_income += amount
            wallet.version += 1
            
            # 乐观锁更新
            result = await self.db.execute(
                update(UserWallet)
                .where(UserWallet.user_id == user_id, UserWallet.version == old_version)
                .values(
                    balance=wallet.balance,
                    total_income=wallet.total_income,
                    version=wallet.version
                )
            )
            
            if result.rowcount > 0:
                await self.db.commit()
                return True
        
        raise BusinessException("余额更新失败，请重试")
    
    def _generate_token(self, user_id: str) -> str:
        """生成JWT Token"""
        payload = {
            "user_id": user_id,
            "exp": datetime.utcnow() + timedelta(days=7),
            "iat": datetime.utcnow()
        }
        return jwt.encode(payload, self.config.JWT_SECRET, algorithm="HS256")
```

#### 4.1.3 API接口

```python
# api/user_router.py
from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel

router = APIRouter(prefix="/user", tags=["用户"])

class WechatLoginRequest(BaseModel):
    code: str

class WechatLoginResponse(BaseModel):
    user_id: str
    token: str
    is_new_user: bool
    is_verified: bool

@router.post("/login/wechat", response_model=WechatLoginResponse)
async def login_by_wechat(
    request: WechatLoginRequest,
    user_service: UserService = Depends(get_user_service)
):
    """微信登录"""
    result = await user_service.login_by_wechat(request.code)
    return WechatLoginResponse(**result)


class VerifyIdentityRequest(BaseModel):
    real_name: str
    id_card: str

@router.post("/verify")
async def verify_identity(
    request: VerifyIdentityRequest,
    current_user: User = Depends(get_current_user),
    user_service: UserService = Depends(get_user_service)
):
    """实名认证"""
    await user_service.verify_identity(
        current_user.user_id,
        request.real_name,
        request.id_card
    )
    return {"message": "认证成功"}


@router.get("/wallet/balance")
async def get_wallet_balance(
    current_user: User = Depends(get_current_user),
    user_service: UserService = Depends(get_user_service)
):
    """获取钱包余额"""
    return await user_service.get_wallet_balance(current_user.user_id)
```

### 4.2 订单服务 (order-svc)

#### 4.2.1 模块职责

- 投递凭证解析与验证
- 订单创建与管理
- 金额领取处理
- 订单状态流转
- 投递记录查询

#### 4.2.2 核心类设计

```python
# services/order_service.py
import hmac
import hashlib
import base64
import json
from datetime import datetime
from decimal import Decimal

class OrderService:
    """订单服务"""
    
    # 碳减排系数: 1kg衣物 = 2.5kg CO2
    CARBON_COEFFICIENT = Decimal("2.5")
    # 积分系数: 1kg CO2 = 10积分
    POINTS_COEFFICIENT = 10
    
    def __init__(self, db_session, redis_client, device_service, user_service):
        self.db = db_session
        self.redis = redis_client
        self.device_service = device_service
        self.user_service = user_service
    
    async def scan_qrcode(self, qrcode_data: str, user_id: str = None) -> dict:
        """
        扫码解析投递凭证
        
        流程:
        1. Base64解码二维码数据
        2. 解析JSON，提取投递凭证信息
        3. 验证签名
        4. 检查是否过期
        5. 查询或创建订单
        """
        # 1. 解码二维码数据
        try:
            decoded_data = base64.b64decode(qrcode_data)
            voucher_data = json.loads(decoded_data)
        except Exception:
            raise BusinessException(10006, "投递凭证数据格式错误")
        
        # 2. 提取关键字段
        device_id = voucher_data.get("d")
        voucher_id = voucher_data.get("vid")
        weight_gram = voucher_data.get("w")  # 克
        unit_price_fen = voucher_data.get("p")  # 分/kg
        amount_fen = voucher_data.get("a")  # 分
        generate_time = voucher_data.get("t")
        expire_time = voucher_data.get("e")
        signature = voucher_data.get("s")
        
        # 3. 验证签名
        device = await self.device_service.get_device(device_id)
        if not device:
            raise BusinessException(10002, "设备不存在或未注册")
        
        is_valid = self._verify_signature(voucher_data, device.device_secret)
        if not is_valid:
            raise BusinessException(10001, "二维码数据无效或签名验证失败")
        
        # 4. 检查是否过期
        if datetime.now().timestamp() > expire_time:
            raise BusinessException(10004, "二维码已过期")
        
        # 5. 查询是否已存在订单
        existing_order = await self._get_order_by_voucher_id(voucher_id)
        if existing_order:
            if existing_order.status == OrderStatus.CLAIMED:
                raise BusinessException(10003, "订单已被领取")
            return self._build_order_response(existing_order, is_new_order=False)
        
        # 6. 创建新订单
        order = await self._create_order(
            voucher_id=voucher_id,
            device_id=device_id,
            weight_gram=weight_gram,
            unit_price_fen=unit_price_fen,
            amount_fen=amount_fen,
            generate_time=generate_time,
            expire_time=expire_time,
            signature=signature,
            qrcode_data=qrcode_data
        )
        
        return self._build_order_response(order, is_new_order=True)
    
    async def claim_order(self, order_id: str, user_id: str) -> dict:
        """
        领取订单金额
        
        流程:
        1. 查询订单，校验状态
        2. 绑定用户
        3. 金额入账
        4. 积分入账
        5. 更新订单状态
        6. 发送通知
        """
        # 1. 查询订单
        order = await self._get_order_by_id(order_id)
        if not order:
            raise BusinessException(10002, "订单不存在")
        
        if order.status == OrderStatus.CLAIMED:
            raise BusinessException(10003, "订单已被领取")
        
        if order.status == OrderStatus.EXPIRED:
            raise BusinessException(10004, "订单已过期")
        
        # 2. 开启事务
        async with self.db.begin():
            # 3. 绑定用户
            order.user_id = user_id
            order.status = OrderStatus.CLAIMED
            order.claim_time = datetime.now()
            
            # 4. 金额入账
            amount = float(order.amount)
            await self.user_service.add_balance(user_id, amount, order_id)
            
            # 5. 积分入账
            points = int(order.carbon_reduction * self.POINTS_COEFFICIENT)
            order.points_earned = points
            await self.user_service.add_points(user_id, points, order_id)
            
            await self.db.commit()
        
        # 6. 发送通知（异步）
        await self._publish_order_claimed_event(order)
        
        # 7. 返回结果
        wallet = await self.user_service.get_wallet_balance(user_id)
        total_points = await self.user_service.get_total_points(user_id)
        
        return {
            "order_id": order.order_id,
            "voucher_id": order.voucher_id,
            "weight": float(order.weight),
            "unit_price": float(order.unit_price),
            "amount": float(order.amount),
            "carbon_reduction": float(order.carbon_reduction),
            "points_earned": order.points_earned,
            "wallet_balance": wallet["balance"],
            "total_points": total_points,
            "claim_time": order.claim_time.isoformat()
        }
    
    def _verify_signature(self, voucher_data: dict, device_secret: str) -> bool:
        """验证签名"""
        # 拼接待签名字符串
        sign_str = "{v}.{d}.{vid}.{w}.{p}.{a}.{t}.{e}".format(
            v=voucher_data["v"],
            d=voucher_data["d"],
            vid=voucher_data["vid"],
            w=voucher_data["w"],
            p=voucher_data["p"],
            a=voucher_data["a"],
            t=voucher_data["t"],
            e=voucher_data["e"]
        )
        
        # 计算HMAC-SHA256
        expected_signature = hmac.new(
            device_secret.encode(),
            sign_str.encode(),
            hashlib.sha256
        ).hexdigest()
        
        return hmac.compare_digest(voucher_data["s"], expected_signature)
    
    async def _create_order(self, **kwargs) -> Order:
        """创建订单"""
        # 转换单位
        weight_kg = Decimal(kwargs["weight_gram"]) / 1000
        unit_price_yuan = Decimal(kwargs["unit_price_fen"]) / 100
        amount_yuan = Decimal(kwargs["amount_fen"]) / 100
        
        # 计算碳减排量
        carbon_reduction = weight_kg * self.CARBON_COEFFICIENT
        
        order = Order(
            order_id=self._generate_order_id(),
            voucher_id=kwargs["voucher_id"],
            device_id=kwargs["device_id"],
            weight=weight_kg,
            unit_price=unit_price_yuan,
            amount=amount_yuan,
            carbon_reduction=carbon_reduction,
            status=OrderStatus.PENDING,
            signature=kwargs["signature"],
            qrcode_data=kwargs["qrcode_data"],
            qrcode_generate_time=datetime.fromtimestamp(kwargs["generate_time"]),
            qrcode_expire_time=datetime.fromtimestamp(kwargs["expire_time"]),
            scan_time=datetime.now(),
            source="scan"
        )
        
        self.db.add(order)
        await self.db.commit()
        
        return order
    
    def _generate_order_id(self) -> str:
        """生成订单ID"""
        # ORD + 年月日 + 6位随机数
        from datetime import datetime
        import random
        date_str = datetime.now().strftime("%Y%m%d")
        random_str = str(random.randint(100000, 999999))
        return f"ORD{date_str}{random_str}"
```

#### 4.2.3 API接口

```python
# api/order_router.py
from fastapi import APIRouter, Depends
from pydantic import BaseModel
from typing import Optional, List

router = APIRouter(prefix="/order", tags=["订单"])

class ScanQrcodeRequest(BaseModel):
    qrcode_data: str  # Base64编码的二维码内容

class ScanQrcodeResponse(BaseModel):
    order_id: str
    voucher_id: str
    device_id: str
    device_name: str
    weight: float
    unit_price: float
    amount: float
    carbon_reduction: float
    points: int
    status: str
    delivery_time: str
    qrcode_expire_time: str
    is_new_order: bool

@router.post("/scan", response_model=ScanQrcodeResponse)
async def scan_qrcode(
    request: ScanQrcodeRequest,
    current_user: Optional[User] = Depends(get_current_user_optional),
    order_service: OrderService = Depends(get_order_service)
):
    """扫码解析投递凭证"""
    user_id = current_user.user_id if current_user else None
    result = await order_service.scan_qrcode(request.qrcode_data, user_id)
    return ScanQrcodeResponse(**result)


class ClaimOrderResponse(BaseModel):
    order_id: str
    voucher_id: str
    weight: float
    amount: float
    carbon_reduction: float
    points_earned: int
    wallet_balance: float
    total_points: int
    claim_time: str

@router.post("/{order_id}/claim", response_model=ClaimOrderResponse)
async def claim_order(
    order_id: str,
    current_user: User = Depends(get_current_user),
    order_service: OrderService = Depends(get_order_service)
):
    """领取订单金额"""
    result = await order_service.claim_order(order_id, current_user.user_id)
    return ClaimOrderResponse(**result)


class OrderListResponse(BaseModel):
    total: int
    page: int
    page_size: int
    items: List[dict]

@router.get("/list", response_model=OrderListResponse)
async def get_order_list(
    page: int = 1,
    page_size: int = 20,
    status: Optional[int] = None,
    current_user: User = Depends(get_current_user),
    order_service: OrderService = Depends(get_order_service)
):
    """获取投递记录列表"""
    result = await order_service.get_order_list(
        user_id=current_user.user_id,
        page=page,
        page_size=page_size,
        status=status
    )
    return OrderListResponse(**result)
```

### 4.3 设备服务 (device-svc)

#### 4.3.1 模块职责

- 设备注册与管理
- 心跳数据处理
- 设备状态监控
- 投递记录接收（通过心跳）
- 报警处理
- 配置下发

#### 4.3.2 核心类设计

```python
# services/device_service.py
from datetime import datetime, timedelta
from typing import List, Optional
import json

class DeviceService:
    """设备服务"""
    
    HEARTBEAT_TIMEOUT = 90  # 心跳超时时间(秒)
    
    def __init__(self, db_session, redis_client, mqtt_client, order_service):
        self.db = db_session
        self.redis = redis_client
        self.mqtt = mqtt_client
        self.order_service = order_service
    
    async def handle_heartbeat(self, device_id: str, heartbeat_data: dict) -> dict:
        """
        处理设备心跳
        
        流程:
        1. 更新设备在线状态
        2. 存储设备状态数据
        3. 处理携带的投递记录
        4. 返回ACK响应
        """
        timestamp = heartbeat_data.get("timestamp")
        seq = heartbeat_data.get("seq")
        data = heartbeat_data.get("data", {})
        
        # 1. 更新设备在线状态
        device = await self._get_device(device_id)
        if not device:
            raise BusinessException("设备不存在")
        
        device.online_status = 1
        device.last_heartbeat = datetime.now()
        device.capacity_percent = data.get("capacity_percent", 0)
        
        # 2. 存储设备状态到Redis（用于实时监控）
        await self._cache_device_status(device_id, data)
        
        # 3. 存储设备状态历史到MongoDB（用于数据分析）
        await self._save_device_status_history(device_id, data, timestamp)
        
        # 4. 处理携带的投递记录
        deliveries = data.get("deliveries", [])
        received_vouchers = []
        
        for delivery in deliveries:
            try:
                await self._process_delivery_record(device_id, delivery)
                received_vouchers.append(delivery["voucher_id"])
            except Exception as e:
                # 记录处理失败的投递，不影响其他记录
                logger.error(f"处理投递记录失败: {delivery['voucher_id']}, {e}")
        
        await self.db.commit()
        
        # 5. 检查是否需要同步配置
        config_version = await self._get_device_config_version(device_id)
        
        # 6. 返回ACK响应
        return {
            "msg_type": "heartbeat_ack",
            "device_id": device_id,
            "timestamp": int(datetime.now().timestamp()),
            "data": {
                "received_vouchers": received_vouchers,
                "config_version": config_version,
                "server_time": int(datetime.now().timestamp())
            }
        }
    
    async def _process_delivery_record(self, device_id: str, delivery: dict):
        """处理投递记录"""
        voucher_id = delivery["voucher_id"]
        
        # 检查是否已存在订单
        existing_order = await self.order_service.get_order_by_voucher_id(voucher_id)
        
        if existing_order:
            # 订单已存在（用户已扫码），补充设备上报数据
            if not existing_order.device_reported:
                existing_order.device_reported = True
                existing_order.device_report_time = datetime.now()
        else:
            # 订单不存在（用户未扫码），创建待认领订单
            await self.order_service.create_order_from_heartbeat(
                device_id=device_id,
                voucher_id=voucher_id,
                weight_gram=delivery["weight"],
                unit_price_fen=delivery["unit_price"],
                amount_fen=delivery["amount"],
                door_open_time=delivery.get("door_open_time"),
                door_close_time=delivery.get("door_close_time"),
                qrcode_time=delivery.get("qrcode_time"),
                signature=delivery.get("signature")
            )
    
    async def handle_alarm(self, device_id: str, alarm_data: dict):
        """处理报警事件"""
        alarm_type = alarm_data["data"]["alarm_type"]
        alarm_level = alarm_data["data"]["alarm_level"]
        
        # 1. 保存报警记录
        alarm = DeviceAlarm(
            alarm_id=self._generate_alarm_id(),
            device_id=device_id,
            alarm_type=alarm_type,
            alarm_level=alarm_level,
            alarm_data=json.dumps(alarm_data["data"]),
            status=0  # 未处理
        )
        self.db.add(alarm)
        await self.db.commit()
        
        # 2. 根据报警级别处理
        if alarm_level >= 2:
            # 高级别报警，立即通知运维人员
            await self._notify_alarm(device_id, alarm)
            
            # 烟雾报警，下发锁定指令
            if alarm_type == "smoke":
                await self._send_lock_command(device_id)
    
    async def send_config(self, device_id: str):
        """下发设备配置"""
        device = await self._get_device(device_id)
        
        config_msg = {
            "msg_type": "config_update",
            "device_id": device_id,
            "timestamp": int(datetime.now().timestamp()),
            "config": {
                "unit_price": device.unit_price * 100,  # 转为分
                "min_weight": device.min_weight,
                "qrcode_expire": device.qrcode_expire_seconds,
                "device_name": device.device_name
            }
        }
        
        topic = f"device/{device_id}/config"
        await self.mqtt.publish(topic, json.dumps(config_msg))
    
    async def check_offline_devices(self):
        """检查离线设备（定时任务）"""
        threshold = datetime.now() - timedelta(seconds=self.HEARTBEAT_TIMEOUT)
        
        offline_devices = await self.db.query(Device).filter(
            Device.online_status == 1,
            Device.last_heartbeat < threshold
        ).all()
        
        for device in offline_devices:
            device.online_status = 0
            # 创建离线报警
            await self._create_offline_alarm(device.device_id)
        
        await self.db.commit()
```

---

## 5. 硬件通信设计

### 5.1 MQTT通信架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           MQTT 通信架构                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ┌───────────────┐                              ┌───────────────────────┐  │
│   │   智能回收箱   │                              │      后端服务         │  │
│   │   (MQTT客户端) │                              │    (mqtt-bridge)     │  │
│   └───────┬───────┘                              └───────────┬───────────┘  │
│           │                                                  │              │
│           │  TLS 1.3 加密                                    │              │
│           │                                                  │              │
│           ▼                                                  ▼              │
│   ┌─────────────────────────────────────────────────────────────────────┐  │
│   │                        EMQX Broker                                   │  │
│   │                                                                      │  │
│   │  ┌──────────────────┐    ┌──────────────────┐    ┌────────────────┐ │  │
│   │  │  设备认证模块     │    │   消息路由模块    │    │  Webhook模块   │ │  │
│   │  │  (证书+密钥)     │    │   (Topic匹配)    │    │  (消息转发)    │ │  │
│   │  └──────────────────┘    └──────────────────┘    └────────────────┘ │  │
│   │                                                                      │  │
│   └─────────────────────────────────────────────────────────────────────┘  │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 5.2 Topic设计

```python
# mqtt/topics.py

class MQTTTopics:
    """MQTT Topic定义"""
    
    # 设备上行
    HEARTBEAT = "device/{device_id}/heartbeat"      # 心跳上报
    ALARM = "device/{device_id}/alarm"              # 报警事件
    
    # 设备下行
    COMMAND = "device/{device_id}/command"          # 控制指令
    CONFIG = "device/{device_id}/config"            # 配置下发
    OTA = "device/{device_id}/ota"                  # 固件升级
    
    @classmethod
    def get_heartbeat_topic(cls, device_id: str) -> str:
        return cls.HEARTBEAT.format(device_id=device_id)
    
    @classmethod
    def get_command_topic(cls, device_id: str) -> str:
        return cls.COMMAND.format(device_id=device_id)
```

### 5.3 MQTT Bridge 服务

```python
# services/mqtt_bridge.py
import asyncio
import json
from aiomqtt import Client
from loguru import logger

class MQTTBridge:
    """MQTT消息桥接服务"""
    
    def __init__(self, config, device_service):
        self.config = config
        self.device_service = device_service
        self.client = None
    
    async def start(self):
        """启动MQTT连接"""
        self.client = Client(
            hostname=self.config.MQTT_HOST,
            port=self.config.MQTT_PORT,
            username=self.config.MQTT_USERNAME,
            password=self.config.MQTT_PASSWORD,
            tls_context=self._create_tls_context()
        )
        
        async with self.client:
            # 订阅所有设备的上行消息
            await self.client.subscribe("device/+/heartbeat")
            await self.client.subscribe("device/+/alarm")
            
            logger.info("MQTT Bridge started, listening for messages...")
            
            async for message in self.client.messages:
                await self._handle_message(message)
    
    async def _handle_message(self, message):
        """处理接收到的MQTT消息"""
        topic = str(message.topic)
        payload = json.loads(message.payload.decode())
        
        # 解析device_id
        parts = topic.split("/")
        device_id = parts[1]
        msg_type = parts[2]
        
        logger.debug(f"Received {msg_type} from {device_id}")
        
        try:
            if msg_type == "heartbeat":
                response = await self.device_service.handle_heartbeat(device_id, payload)
                # 发送ACK响应
                await self._send_response(device_id, response)
            
            elif msg_type == "alarm":
                await self.device_service.handle_alarm(device_id, payload)
        
        except Exception as e:
            logger.error(f"Handle message error: {e}")
    
    async def _send_response(self, device_id: str, response: dict):
        """发送响应到设备"""
        topic = f"device/{device_id}/command"
        await self.client.publish(topic, json.dumps(response))
    
    async def publish(self, topic: str, payload: str):
        """发布消息"""
        if self.client:
            await self.client.publish(topic, payload)
```

### 5.4 设备认证方案

```python
# auth/device_auth.py
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography import x509

class DeviceAuthenticator:
    """设备认证器"""
    
    def __init__(self, ca_cert_path: str, db_session):
        self.ca_cert = self._load_ca_cert(ca_cert_path)
        self.db = db_session
    
    def verify_device_certificate(self, cert_pem: str) -> bool:
        """验证设备证书"""
        try:
            device_cert = x509.load_pem_x509_certificate(cert_pem.encode())
            
            # 验证证书是否由CA签发
            self.ca_cert.public_key().verify(
                device_cert.signature,
                device_cert.tbs_certificate_bytes,
                padding.PKCS1v15(),
                device_cert.signature_hash_algorithm,
            )
            
            # 验证证书是否过期
            if device_cert.not_valid_after < datetime.utcnow():
                return False
            
            return True
        except Exception:
            return False
    
    async def authenticate_device(self, device_id: str, client_id: str, password: str) -> bool:
        """
        设备认证
        使用设备ID + 密钥方式认证
        """
        device = await self.db.query(Device).filter_by(device_id=device_id).first()
        
        if not device:
            return False
        
        # 验证密钥
        expected_password = self._generate_connect_password(device_id, device.device_secret)
        return hmac.compare_digest(password, expected_password)
    
    def _generate_connect_password(self, device_id: str, secret: str) -> str:
        """生成连接密码"""
        timestamp = int(datetime.now().timestamp() // 3600)  # 按小时变化
        sign_str = f"{device_id}.{timestamp}"
        return hmac.new(secret.encode(), sign_str.encode(), hashlib.sha256).hexdigest()
```

---

## 6. 小程序设计

### 6.1 小程序架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                          小程序架构                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                           页面层 (Pages)                             │   │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────────┐   │   │
│  │  │  首页   │ │  扫码   │ │  订单   │ │  钱包   │ │    我的     │   │   │
│  │  │ index  │ │  scan   │ │ orders │ │ wallet │ │   profile   │   │   │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          组件层 (Components)                         │   │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────────┐   │   │
│  │  │ DeviceCard │ │ OrderCard │ │ QRScanner │ │  BalanceDisplay  │   │   │
│  │  └───────────┘ └───────────┘ └───────────┘ └───────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          服务层 (Services)                           │   │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────────┐   │   │
│  │  │ userSvc   │ │ orderSvc  │ │ deviceSvc │ │    walletSvc      │   │   │
│  │  └───────────┘ └───────────┘ └───────────┘ └───────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                    │                                        │
│                                    ▼                                        │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │                          工具层 (Utils)                              │   │
│  │  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────────────┐   │   │
│  │  │  request  │ │   auth    │ │  storage  │ │      utils        │   │   │
│  │  └───────────┘ └───────────┘ └───────────┘ └───────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 目录结构

```
miniprogram/
├── app.js                    # 小程序入口
├── app.json                  # 全局配置
├── app.wxss                  # 全局样式
├── pages/                    # 页面目录
│   ├── index/               # 首页
│   │   ├── index.js
│   │   ├── index.json
│   │   ├── index.wxml
│   │   └── index.wxss
│   ├── scan/                # 扫码页
│   │   ├── scan.js
│   │   └── ...
│   ├── claim/               # 领取页
│   │   ├── claim.js
│   │   └── ...
│   ├── orders/              # 订单列表
│   │   ├── orders.js
│   │   └── ...
│   ├── wallet/              # 钱包
│   │   ├── wallet.js
│   │   └── ...
│   └── profile/             # 个人中心
│       ├── profile.js
│       └── ...
├── components/              # 组件目录
│   ├── device-card/        # 设备卡片
│   ├── order-card/         # 订单卡片
│   └── ...
├── services/               # 服务层
│   ├── user.js            # 用户服务
│   ├── order.js           # 订单服务
│   ├── device.js          # 设备服务
│   └── wallet.js          # 钱包服务
├── utils/                  # 工具函数
│   ├── request.js         # 网络请求封装
│   ├── auth.js            # 认证相关
│   ├── storage.js         # 存储封装
│   └── util.js            # 通用工具
└── config/                 # 配置
    └── index.js           # 环境配置
```

### 6.3 核心代码示例

```javascript
// utils/request.js
const config = require('../config/index');

class Request {
  constructor() {
    this.baseUrl = config.API_BASE_URL;
  }

  async request(options) {
    const token = wx.getStorageSync('token');
    
    const header = {
      'Content-Type': 'application/json',
      ...options.header
    };
    
    if (token) {
      header['Authorization'] = `Bearer ${token}`;
    }

    return new Promise((resolve, reject) => {
      wx.request({
        url: `${this.baseUrl}${options.url}`,
        method: options.method || 'GET',
        data: options.data,
        header,
        success: (res) => {
          if (res.statusCode === 200) {
            if (res.data.code === 0) {
              resolve(res.data.data);
            } else {
              // 业务错误
              this.handleError(res.data);
              reject(res.data);
            }
          } else if (res.statusCode === 401) {
            // Token过期，重新登录
            this.handleUnauthorized();
            reject(res.data);
          } else {
            reject(res.data);
          }
        },
        fail: (err) => {
          wx.showToast({ title: '网络错误', icon: 'none' });
          reject(err);
        }
      });
    });
  }

  get(url, data) {
    return this.request({ url, method: 'GET', data });
  }

  post(url, data) {
    return this.request({ url, method: 'POST', data });
  }

  handleError(data) {
    wx.showToast({ title: data.message || '操作失败', icon: 'none' });
  }

  handleUnauthorized() {
    wx.removeStorageSync('token');
    wx.redirectTo({ url: '/pages/login/login' });
  }
}

module.exports = new Request();
```

```javascript
// services/order.js
const request = require('../utils/request');

class OrderService {
  /**
   * 扫码解析投递凭证
   */
  async scanQrcode(qrcodeData) {
    return request.post('/order/scan', {
      qrcode_data: qrcodeData
    });
  }

  /**
   * 领取订单金额
   */
  async claimOrder(orderId) {
    return request.post(`/order/${orderId}/claim`);
  }

  /**
   * 获取订单列表
   */
  async getOrderList(page = 1, pageSize = 20) {
    return request.get('/order/list', { page, page_size: pageSize });
  }

  /**
   * 获取订单详情
   */
  async getOrderDetail(orderId) {
    return request.get(`/order/${orderId}/detail`);
  }
}

module.exports = new OrderService();
```

```javascript
// pages/scan/scan.js
const orderService = require('../../services/order');
const userService = require('../../services/user');

Page({
  data: {
    scanning: false,
    orderInfo: null,
    showClaimModal: false
  },

  onLoad() {
    this.checkLogin();
  },

  async checkLogin() {
    const token = wx.getStorageSync('token');
    if (!token) {
      // 未登录，先登录
      await this.login();
    }
  },

  async login() {
    try {
      const { code } = await wx.login();
      const result = await userService.loginByWechat(code);
      wx.setStorageSync('token', result.token);
      wx.setStorageSync('userInfo', result);
    } catch (e) {
      console.error('登录失败', e);
    }
  },

  // 开始扫码
  startScan() {
    this.setData({ scanning: true });
    
    wx.scanCode({
      onlyFromCamera: true,
      success: async (res) => {
        try {
          // 解析二维码
          const qrcodeData = res.result;
          const orderInfo = await orderService.scanQrcode(qrcodeData);
          
          this.setData({
            orderInfo,
            showClaimModal: true
          });
        } catch (e) {
          wx.showToast({ title: e.message || '二维码无效', icon: 'none' });
        }
      },
      complete: () => {
        this.setData({ scanning: false });
      }
    });
  },

  // 确认领取
  async confirmClaim() {
    const { orderInfo } = this.data;
    
    try {
      wx.showLoading({ title: '领取中...' });
      
      const result = await orderService.claimOrder(orderInfo.order_id);
      
      wx.hideLoading();
      
      // 跳转到领取成功页
      wx.navigateTo({
        url: `/pages/claim-success/claim-success?data=${encodeURIComponent(JSON.stringify(result))}`
      });
    } catch (e) {
      wx.hideLoading();
      wx.showToast({ title: e.message || '领取失败', icon: 'none' });
    }
  },

  // 关闭弹窗
  closeModal() {
    this.setData({ showClaimModal: false, orderInfo: null });
  }
});
```

```xml
<!-- pages/scan/scan.wxml -->
<view class="container">
  <!-- 扫码区域 -->
  <view class="scan-area">
    <view class="scan-frame">
      <image src="/images/scan-frame.png" mode="aspectFit" />
    </view>
    <text class="scan-tip">将二维码放入框内，即可自动扫描</text>
  </view>

  <!-- 扫码按钮 -->
  <button class="scan-btn" bindtap="startScan" loading="{{scanning}}">
    开始扫码
  </button>

  <!-- 领取弹窗 -->
  <view class="modal" wx:if="{{showClaimModal}}">
    <view class="modal-content">
      <view class="modal-header">
        <text class="title">投递详情</text>
        <text class="close" bindtap="closeModal">×</text>
      </view>
      
      <view class="modal-body">
        <view class="info-item">
          <text class="label">设备位置</text>
          <text class="value">{{orderInfo.device_name}}</text>
        </view>
        <view class="info-item">
          <text class="label">投递重量</text>
          <text class="value">{{orderInfo.weight}} kg</text>
        </view>
        <view class="info-item highlight">
          <text class="label">可领金额</text>
          <text class="value amount">¥{{orderInfo.amount}}</text>
        </view>
        <view class="info-item">
          <text class="label">碳减排量</text>
          <text class="value">{{orderInfo.carbon_reduction}} kg CO₂</text>
        </view>
        <view class="info-item">
          <text class="label">获得积分</text>
          <text class="value">{{orderInfo.points}} 分</text>
        </view>
      </view>
      
      <view class="modal-footer">
        <button class="btn-cancel" bindtap="closeModal">取消</button>
        <button class="btn-confirm" bindtap="confirmClaim">确认领取</button>
      </view>
    </view>
  </view>
</view>
```

---

## 7. 后台管理系统设计

### 7.1 技术架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         后台管理系统架构                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                          Vue3 + TypeScript                             │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                      │                                      │
│  ┌───────────────────────────────────┼───────────────────────────────────┐ │
│  │                                   ▼                                    │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │ │
│  │  │  Vue Router │  │    Pinia    │  │ Element Plus│  │   ECharts   │  │ │
│  │  │   (路由)    │  │   (状态)    │  │   (UI库)    │  │   (图表)    │  │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                      │                                      │
│  ┌───────────────────────────────────┼───────────────────────────────────┐ │
│  │                                   ▼                                    │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  │ │
│  │  │    Axios    │  │   Vite      │  │   UnoCSS    │  │  VueUse     │  │ │
│  │  │  (HTTP)     │  │   (构建)    │  │   (样式)    │  │  (工具)     │  │ │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘  │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 7.2 目录结构

```
admin-web/
├── src/
│   ├── api/                 # API接口
│   │   ├── user.ts
│   │   ├── device.ts
│   │   ├── order.ts
│   │   └── ...
│   ├── assets/             # 静态资源
│   ├── components/         # 公共组件
│   │   ├── Charts/
│   │   ├── Table/
│   │   └── ...
│   ├── composables/        # 组合式函数
│   ├── layouts/            # 布局组件
│   ├── router/             # 路由配置
│   ├── stores/             # Pinia状态
│   ├── styles/             # 全局样式
│   ├── types/              # 类型定义
│   ├── utils/              # 工具函数
│   ├── views/              # 页面视图
│   │   ├── dashboard/      # 工作台
│   │   ├── device/         # 设备管理
│   │   ├── order/          # 订单管理
│   │   ├── user/           # 用户管理
│   │   ├── finance/        # 财务管理
│   │   └── system/         # 系统管理
│   ├── App.vue
│   └── main.ts
├── index.html
├── vite.config.ts
├── tsconfig.json
└── package.json
```

### 7.3 权限设计

```typescript
// types/permission.ts
export enum Permission {
  // 工作台
  DASHBOARD_VIEW = 'dashboard:view',
  
  // 设备管理
  DEVICE_VIEW = 'device:view',
  DEVICE_EDIT = 'device:edit',
  DEVICE_CONTROL = 'device:control',
  
  // 订单管理
  ORDER_VIEW = 'order:view',
  ORDER_AUDIT = 'order:audit',
  ORDER_REFUND = 'order:refund',
  
  // 用户管理
  USER_VIEW = 'user:view',
  USER_EDIT = 'user:edit',
  USER_BAN = 'user:ban',
  
  // 财务管理
  FINANCE_VIEW = 'finance:view',
  FINANCE_WITHDRAW_AUDIT = 'finance:withdraw:audit',
  
  // 系统管理
  SYSTEM_CONFIG = 'system:config',
  SYSTEM_ROLE = 'system:role',
  SYSTEM_ACCOUNT = 'system:account'
}

// 角色定义
export const Roles = {
  SUPER_ADMIN: {
    name: '超级管理员',
    permissions: Object.values(Permission)
  },
  OPERATOR: {
    name: '运营人员',
    permissions: [
      Permission.DASHBOARD_VIEW,
      Permission.DEVICE_VIEW,
      Permission.ORDER_VIEW,
      Permission.USER_VIEW
    ]
  },
  FINANCE: {
    name: '财务人员',
    permissions: [
      Permission.DASHBOARD_VIEW,
      Permission.FINANCE_VIEW,
      Permission.FINANCE_WITHDRAW_AUDIT,
      Permission.ORDER_VIEW
    ]
  },
  MAINTENANCE: {
    name: '运维人员',
    permissions: [
      Permission.DASHBOARD_VIEW,
      Permission.DEVICE_VIEW,
      Permission.DEVICE_EDIT,
      Permission.DEVICE_CONTROL
    ]
  }
};
```

---

## 8. 数据库详细设计

### 8.1 MySQL数据库配置

```sql
-- 数据库创建
CREATE DATABASE IF NOT EXISTS clothing_recycle 
CHARACTER SET utf8mb4 
COLLATE utf8mb4_unicode_ci;

USE clothing_recycle;

-- 设置全局参数
SET GLOBAL innodb_buffer_pool_size = 1073741824;  -- 1GB
SET GLOBAL max_connections = 500;
SET GLOBAL innodb_flush_log_at_trx_commit = 2;
```

### 8.2 索引设计原则

| 表名 | 索引字段 | 索引类型 | 用途 |
|-----|---------|---------|------|
| users | user_id | UNIQUE | 主键查询 |
| users | phone | INDEX | 手机号登录 |
| users | openid_wechat | INDEX | 微信登录 |
| delivery_orders | voucher_id | UNIQUE | 凭证查询(防重复) |
| delivery_orders | user_id + created_at | COMPOSITE | 用户订单列表 |
| delivery_orders | device_id + created_at | COMPOSITE | 设备订单统计 |
| delivery_orders | status + qrcode_expire_time | COMPOSITE | 过期订单处理 |
| devices | device_id | UNIQUE | 设备查询 |
| devices | longitude, latitude | SPATIAL | 附近设备查询 |

### 8.3 分表策略

```python
# 订单表按月分表
# delivery_orders_202601, delivery_orders_202602, ...

class OrderSharding:
    """订单分表策略"""
    
    @staticmethod
    def get_table_name(order_time: datetime) -> str:
        """根据订单时间获取表名"""
        return f"delivery_orders_{order_time.strftime('%Y%m')}"
    
    @staticmethod
    def get_table_name_by_order_id(order_id: str) -> str:
        """根据订单ID获取表名"""
        # ORD20260102123456 -> delivery_orders_202601
        date_str = order_id[3:9]
        return f"delivery_orders_{date_str[:6]}"
```

---

## 9. 缓存设计

### 9.1 Redis缓存架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           Redis 缓存架构                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  ┌───────────────────────────────────────────────────────────────────────┐ │
│  │                    Redis Cluster (3主3从)                              │ │
│  │                                                                        │ │
│  │   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐               │ │
│  │   │  Master 1   │    │  Master 2   │    │  Master 3   │               │ │
│  │   │ (slots 0-5460)│   │(slots 5461-10922)│ │(slots 10923-16383)│        │ │
│  │   └──────┬──────┘    └──────┬──────┘    └──────┬──────┘               │ │
│  │          │                  │                  │                       │ │
│  │   ┌──────▼──────┐    ┌──────▼──────┐    ┌──────▼──────┐               │ │
│  │   │   Slave 1   │    │   Slave 2   │    │   Slave 3   │               │ │
│  │   └─────────────┘    └─────────────┘    └─────────────┘               │ │
│  │                                                                        │ │
│  └───────────────────────────────────────────────────────────────────────┘ │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 9.2 缓存Key设计

```python
# cache/keys.py

class CacheKeys:
    """缓存Key定义"""
    
    # 用户相关
    USER_TOKEN = "user:token:{user_id}"           # 用户Token, TTL: 7天
    USER_INFO = "user:info:{user_id}"             # 用户信息, TTL: 1小时
    USER_WALLET = "user:wallet:{user_id}"         # 钱包信息, TTL: 5分钟
    
    # 设备相关
    DEVICE_INFO = "device:info:{device_id}"       # 设备信息, TTL: 1小时
    DEVICE_STATUS = "device:status:{device_id}"   # 设备状态, TTL: 2分钟
    DEVICE_ONLINE = "device:online"               # 在线设备集合 (Set)
    
    # 订单相关
    ORDER_INFO = "order:info:{order_id}"          # 订单信息, TTL: 1小时
    VOUCHER_ORDER = "voucher:order:{voucher_id}"  # 凭证->订单映射, TTL: 24小时
    
    # 统计相关
    STATS_DAILY = "stats:daily:{date}"            # 日统计, TTL: 7天
    STATS_DEVICE_DAILY = "stats:device:{device_id}:{date}"  # 设备日统计
    
    # 分布式锁
    LOCK_ORDER_CLAIM = "lock:order:claim:{order_id}"   # 订单领取锁
    LOCK_WALLET_UPDATE = "lock:wallet:{user_id}"      # 钱包更新锁
    
    # 限流
    RATE_LIMIT_USER = "rate:user:{user_id}"       # 用户请求限流
    RATE_LIMIT_IP = "rate:ip:{ip}"                # IP请求限流
```

### 9.3 缓存操作封装

```python
# cache/redis_client.py
import json
from typing import Optional, Any
from redis.asyncio import Redis
from datetime import timedelta

class RedisClient:
    """Redis客户端封装"""
    
    def __init__(self, redis: Redis):
        self.redis = redis
    
    async def get(self, key: str) -> Optional[Any]:
        """获取缓存"""
        value = await self.redis.get(key)
        if value:
            return json.loads(value)
        return None
    
    async def set(self, key: str, value: Any, ttl: int = None):
        """设置缓存"""
        data = json.dumps(value, default=str)
        if ttl:
            await self.redis.setex(key, ttl, data)
        else:
            await self.redis.set(key, data)
    
    async def delete(self, key: str):
        """删除缓存"""
        await self.redis.delete(key)
    
    async def exists(self, key: str) -> bool:
        """检查key是否存在"""
        return await self.redis.exists(key)
    
    # ===== 分布式锁 =====
    
    async def acquire_lock(self, key: str, ttl: int = 10) -> bool:
        """获取分布式锁"""
        return await self.redis.set(key, "1", nx=True, ex=ttl)
    
    async def release_lock(self, key: str):
        """释放分布式锁"""
        await self.redis.delete(key)
    
    # ===== 限流 =====
    
    async def is_rate_limited(self, key: str, limit: int, window: int) -> bool:
        """滑动窗口限流"""
        current = await self.redis.incr(key)
        if current == 1:
            await self.redis.expire(key, window)
        return current > limit
```

---

## 10. 安全设计

### 10.1 认证鉴权

```python
# auth/jwt_handler.py
from datetime import datetime, timedelta
from typing import Optional
import jwt
from fastapi import HTTPException, Security
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

class JWTHandler:
    """JWT处理器"""
    
    def __init__(self, secret: str, algorithm: str = "HS256"):
        self.secret = secret
        self.algorithm = algorithm
    
    def create_token(self, user_id: str, expires_delta: timedelta = None) -> str:
        """创建JWT Token"""
        if expires_delta is None:
            expires_delta = timedelta(days=7)
        
        payload = {
            "user_id": user_id,
            "exp": datetime.utcnow() + expires_delta,
            "iat": datetime.utcnow(),
            "type": "access"
        }
        
        return jwt.encode(payload, self.secret, algorithm=self.algorithm)
    
    def verify_token(self, token: str) -> dict:
        """验证JWT Token"""
        try:
            payload = jwt.decode(token, self.secret, algorithms=[self.algorithm])
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(status_code=401, detail="Token已过期")
        except jwt.InvalidTokenError:
            raise HTTPException(status_code=401, detail="Token无效")


# FastAPI依赖注入
security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Security(security),
    jwt_handler: JWTHandler = Depends(get_jwt_handler),
    user_service: UserService = Depends(get_user_service)
) -> User:
    """获取当前登录用户"""
    token = credentials.credentials
    payload = jwt_handler.verify_token(token)
    
    user = await user_service.get_user(payload["user_id"])
    if not user:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return user
```

### 10.2 数据加密

```python
# security/encryption.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class DataEncryptor:
    """数据加密器"""
    
    def __init__(self, key: str):
        # 从密钥派生加密密钥
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=b'clothing_recycle_salt',
            iterations=100000,
        )
        derived_key = base64.urlsafe_b64encode(kdf.derive(key.encode()))
        self.cipher = Fernet(derived_key)
    
    def encrypt(self, plaintext: str) -> str:
        """加密"""
        return self.cipher.encrypt(plaintext.encode()).decode()
    
    def decrypt(self, ciphertext: str) -> str:
        """解密"""
        return self.cipher.decrypt(ciphertext.encode()).decode()


# 使用示例
encryptor = DataEncryptor(config.ENCRYPTION_KEY)

# 加密身份证号
encrypted_id_card = encryptor.encrypt("110101199001011234")
# 解密
id_card = encryptor.decrypt(encrypted_id_card)
```

### 10.3 接口限流

```python
# middleware/rate_limit.py
from fastapi import Request, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware

class RateLimitMiddleware(BaseHTTPMiddleware):
    """接口限流中间件"""
    
    def __init__(self, app, redis_client, default_limit: int = 100, window: int = 60):
        super().__init__(app)
        self.redis = redis_client
        self.default_limit = default_limit
        self.window = window
    
    async def dispatch(self, request: Request, call_next):
        # 获取客户端标识
        client_id = self._get_client_id(request)
        
        # 检查是否超过限制
        key = f"rate:ip:{client_id}"
        is_limited = await self.redis.is_rate_limited(key, self.default_limit, self.window)
        
        if is_limited:
            raise HTTPException(status_code=429, detail="请求过于频繁，请稍后再试")
        
        response = await call_next(request)
        return response
    
    def _get_client_id(self, request: Request) -> str:
        # 优先使用X-Real-IP
        forwarded = request.headers.get("X-Real-IP")
        if forwarded:
            return forwarded
        return request.client.host
```

### 10.4 SQL注入防护

```python
# 使用SQLAlchemy ORM自动防止SQL注入
# 错误示范（不要这样做）：
# query = f"SELECT * FROM users WHERE id = {user_id}"

# 正确做法：使用参数化查询
from sqlalchemy import select

async def get_user_by_id(self, user_id: str) -> User:
    stmt = select(User).where(User.user_id == user_id)
    result = await self.db.execute(stmt)
    return result.scalar_one_or_none()
```

---

## 11. 部署架构

### 11.1 生产环境部署架构

```
┌─────────────────────────────────────────────────────────────────────────────────────┐
│                              生产环境部署架构                                        │
├─────────────────────────────────────────────────────────────────────────────────────┤
│                                                                                     │
│                              ┌───────────────┐                                      │
│                              │   CDN加速      │                                      │
│                              │   (静态资源)   │                                      │
│                              └───────┬───────┘                                      │
│                                      │                                              │
│                              ┌───────▼───────┐                                      │
│                              │    SLB/CLB    │                                      │
│                              │   (负载均衡)   │                                      │
│                              └───────┬───────┘                                      │
│                                      │                                              │
│              ┌───────────────────────┼───────────────────────┐                     │
│              │                       │                       │                     │
│      ┌───────▼───────┐       ┌───────▼───────┐       ┌───────▼───────┐            │
│      │   Nginx 1     │       │   Nginx 2     │       │   Nginx 3     │            │
│      └───────┬───────┘       └───────┬───────┘       └───────┬───────┘            │
│              │                       │                       │                     │
│              └───────────────────────┼───────────────────────┘                     │
│                                      │                                              │
│   ┌──────────────────────────────────┼──────────────────────────────────┐          │
│   │                          K8s Cluster                                 │          │
│   │                                                                      │          │
│   │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────────┐   │          │
│   │  │ api-gateway│ │ user-svc   │ │ order-svc  │ │  device-svc    │   │          │
│   │  │  (×3)      │ │  (×2)      │ │  (×3)      │ │   (×2)         │   │          │
│   │  └────────────┘ └────────────┘ └────────────┘ └────────────────┘   │          │
│   │                                                                      │          │
│   │  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────────┐   │          │
│   │  │payment-svc │ │ notify-svc │ │  ai-svc    │ │  mqtt-bridge   │   │          │
│   │  │  (×2)      │ │  (×2)      │ │  (×2)      │ │   (×2)         │   │          │
│   │  └────────────┘ └────────────┘ └────────────┘ └────────────────┘   │          │
│   │                                                                      │          │
│   └──────────────────────────────────────────────────────────────────────┘          │
│                                      │                                              │
│              ┌───────────────────────┼───────────────────────┐                     │
│              │                       │                       │                     │
│      ┌───────▼───────┐       ┌───────▼───────┐       ┌───────▼───────┐            │
│      │  MySQL主从    │       │ Redis Cluster │       │   MongoDB     │            │
│      │  (1主2从)     │       │   (3主3从)    │       │  (3副本集)    │            │
│      └───────────────┘       └───────────────┘       └───────────────┘            │
│                                                                                     │
│      ┌───────────────┐       ┌───────────────┐       ┌───────────────┐            │
│      │   RabbitMQ    │       │  EMQX Broker  │       │   阿里云OSS   │            │
│      │   (镜像队列)   │       │   (集群)      │       │              │            │
│      └───────────────┘       └───────────────┘       └───────────────┘            │
│                                                                                     │
└─────────────────────────────────────────────────────────────────────────────────────┘
```

### 11.2 Docker Compose (开发环境)

```yaml
# docker-compose.yml
version: '3.8'

services:
  # API Gateway
  api-gateway:
    build: ./services/api-gateway
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=mysql+aiomysql://root:password@mysql:3306/clothing_recycle
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - mysql
      - redis

  # User Service
  user-svc:
    build: ./services/user-svc
    ports:
      - "8001:8001"
    environment:
      - DATABASE_URL=mysql+aiomysql://root:password@mysql:3306/clothing_recycle
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mysql
      - redis

  # Order Service
  order-svc:
    build: ./services/order-svc
    ports:
      - "8002:8002"
    environment:
      - DATABASE_URL=mysql+aiomysql://root:password@mysql:3306/clothing_recycle
      - REDIS_URL=redis://redis:6379
    depends_on:
      - mysql
      - redis

  # Device Service
  device-svc:
    build: ./services/device-svc
    ports:
      - "8003:8003"
    environment:
      - DATABASE_URL=mysql+aiomysql://root:password@mysql:3306/clothing_recycle
      - REDIS_URL=redis://redis:6379
      - MQTT_HOST=emqx
      - MQTT_PORT=1883
    depends_on:
      - mysql
      - redis
      - emqx

  # MQTT Bridge
  mqtt-bridge:
    build: ./services/mqtt-bridge
    environment:
      - MQTT_HOST=emqx
      - MQTT_PORT=1883
      - REDIS_URL=redis://redis:6379
    depends_on:
      - emqx
      - redis

  # MySQL
  mysql:
    image: mysql:8.0
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=password
      - MYSQL_DATABASE=clothing_recycle
    volumes:
      - mysql_data:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql

  # Redis
  redis:
    image: redis:7.0
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # MongoDB
  mongodb:
    image: mongo:6.0
    ports:
      - "27017:27017"
    volumes:
      - mongo_data:/data/db

  # RabbitMQ
  rabbitmq:
    image: rabbitmq:3.12-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      - RABBITMQ_DEFAULT_USER=admin
      - RABBITMQ_DEFAULT_PASS=admin

  # EMQX
  emqx:
    image: emqx/emqx:5.3
    ports:
      - "1883:1883"
      - "8083:8083"
      - "18083:18083"
    volumes:
      - emqx_data:/opt/emqx/data

volumes:
  mysql_data:
  redis_data:
  mongo_data:
  emqx_data:
```

### 11.3 Kubernetes部署示例

```yaml
# k8s/deployment-order-svc.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-svc
  namespace: clothing-recycle
spec:
  replicas: 3
  selector:
    matchLabels:
      app: order-svc
  template:
    metadata:
      labels:
        app: order-svc
    spec:
      containers:
      - name: order-svc
        image: registry.cn-hangzhou.aliyuncs.com/clothing-recycle/order-svc:latest
        ports:
        - containerPort: 8002
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: redis-secret
              key: url
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8002
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8002
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: order-svc
  namespace: clothing-recycle
spec:
  selector:
    app: order-svc
  ports:
  - port: 8002
    targetPort: 8002
  type: ClusterIP
```

---

## 12. 项目代码结构

### 12.1 后端项目结构

```
clothing-recycle-backend/
├── services/                          # 微服务目录
│   ├── api-gateway/                   # API网关
│   │   ├── app/
│   │   │   ├── __init__.py
│   │   │   ├── main.py               # FastAPI入口
│   │   │   ├── config.py             # 配置
│   │   │   ├── middleware/           # 中间件
│   │   │   │   ├── auth.py
│   │   │   │   ├── rate_limit.py
│   │   │   │   └── logging.py
│   │   │   └── routes/               # 路由转发
│   │   ├── Dockerfile
│   │   └── requirements.txt
│   │
│   ├── user-svc/                      # 用户服务
│   │   ├── app/
│   │   │   ├── __init__.py
│   │   │   ├── main.py
│   │   │   ├── config.py
│   │   │   ├── api/                  # API路由
│   │   │   │   ├── __init__.py
│   │   │   │   └── user_router.py
│   │   │   ├── models/               # 数据模型
│   │   │   │   ├── __init__.py
│   │   │   │   └── user.py
│   │   │   ├── schemas/              # Pydantic模型
│   │   │   │   ├── __init__.py
│   │   │   │   └── user_schema.py
│   │   │   ├── services/             # 业务逻辑
│   │   │   │   ├── __init__.py
│   │   │   │   └── user_service.py
│   │   │   └── repositories/         # 数据访问
│   │   │       ├── __init__.py
│   │   │       └── user_repo.py
│   │   ├── Dockerfile
│   │   └── requirements.txt
│   │
│   ├── order-svc/                     # 订单服务
│   │   └── ... (同user-svc结构)
│   │
│   ├── device-svc/                    # 设备服务
│   │   └── ...
│   │
│   ├── payment-svc/                   # 支付服务
│   │   └── ...
│   │
│   ├── notify-svc/                    # 通知服务
│   │   └── ...
│   │
│   └── mqtt-bridge/                   # MQTT桥接
│       └── ...
│
├── shared/                            # 共享代码
│   ├── database/                     # 数据库
│   │   ├── __init__.py
│   │   ├── session.py
│   │   └── base.py
│   ├── cache/                        # 缓存
│   │   ├── __init__.py
│   │   ├── redis_client.py
│   │   └── keys.py
│   ├── auth/                         # 认证
│   │   ├── __init__.py
│   │   └── jwt_handler.py
│   ├── security/                     # 安全
│   │   ├── __init__.py
│   │   └── encryption.py
│   ├── utils/                        # 工具
│   │   ├── __init__.py
│   │   ├── id_generator.py
│   │   └── helpers.py
│   └── exceptions/                   # 异常
│       ├── __init__.py
│       └── business_exception.py
│
├── migrations/                        # 数据库迁移
│   └── versions/
│
├── tests/                             # 测试
│   ├── unit/
│   ├── integration/
│   └── e2e/
│
├── scripts/                           # 脚本
│   ├── init_db.py
│   └── seed_data.py
│
├── docker-compose.yml                # Docker编排
├── docker-compose.prod.yml           # 生产Docker编排
├── Makefile                          # 构建脚本
├── requirements.txt                  # 依赖
├── pyproject.toml                    # 项目配置
└── README.md
```

### 12.2 项目初始化脚本

```makefile
# Makefile

.PHONY: install dev test build deploy

# 安装依赖
install:
	pip install -r requirements.txt

# 启动开发环境
dev:
	docker-compose up -d mysql redis mongodb rabbitmq emqx
	uvicorn services.api-gateway.app.main:app --reload --host 0.0.0.0 --port 8000

# 运行测试
test:
	pytest tests/ -v --cov=services --cov-report=html

# 构建Docker镜像
build:
	docker-compose build

# 部署到生产
deploy:
	docker-compose -f docker-compose.prod.yml up -d

# 数据库迁移
migrate:
	alembic upgrade head

# 生成数据库迁移文件
migrate-gen:
	alembic revision --autogenerate -m "$(msg)"

# 代码格式化
format:
	black services/ shared/
	isort services/ shared/

# 代码检查
lint:
	flake8 services/ shared/
	mypy services/ shared/
```

---

## 附录

### 附录A：错误码定义

| 错误码 | 说明 | HTTP状态码 |
|-------|------|-----------|
| 0 | 成功 | 200 |
| 10001 | 二维码数据无效或签名验证失败 | 400 |
| 10002 | 设备不存在或未注册 | 404 |
| 10003 | 订单已被领取 | 400 |
| 10004 | 二维码已过期 | 400 |
| 10005 | 用户未完成实名认证 | 403 |
| 10006 | 投递凭证数据格式错误 | 400 |
| 10007 | 设备密钥不匹配 | 401 |
| 20001 | 余额不足 | 400 |
| 20002 | 提现金额低于最小限额 | 400 |
| 20003 | 超过单日提现上限 | 400 |
| 30001 | 设备离线 | 503 |
| 30002 | 设备满载 | 503 |
| 40001 | 参数错误 | 400 |
| 40002 | 未授权 | 401 |
| 40003 | 权限不足 | 403 |
| 50001 | 服务器内部错误 | 500 |

### 附录B：环境变量配置

```bash
# .env.example

# 应用配置
APP_ENV=development
APP_DEBUG=true
APP_SECRET_KEY=your-secret-key

# 数据库
DATABASE_URL=mysql+aiomysql://user:password@localhost:3306/clothing_recycle

# Redis
REDIS_URL=redis://localhost:6379/0

# MongoDB
MONGODB_URL=mongodb://localhost:27017/clothing_recycle

# JWT
JWT_SECRET=your-jwt-secret
JWT_ALGORITHM=HS256
JWT_EXPIRE_DAYS=7

# 微信
WECHAT_APP_ID=your-app-id
WECHAT_APP_SECRET=your-app-secret

# 支付宝
ALIPAY_APP_ID=your-app-id
ALIPAY_PRIVATE_KEY=your-private-key
ALIPAY_PUBLIC_KEY=alipay-public-key

# 阿里云OSS
OSS_ACCESS_KEY_ID=your-access-key
OSS_ACCESS_KEY_SECRET=your-secret
OSS_BUCKET_NAME=clothing-recycle
OSS_ENDPOINT=oss-cn-hangzhou.aliyuncs.com

# 短信
SMS_ACCESS_KEY_ID=your-access-key
SMS_ACCESS_KEY_SECRET=your-secret
SMS_SIGN_NAME=旧衣回收
SMS_TEMPLATE_CODE=SMS_123456

# MQTT
MQTT_HOST=localhost
MQTT_PORT=1883
MQTT_USERNAME=admin
MQTT_PASSWORD=admin

# 加密
ENCRYPTION_KEY=your-encryption-key
```

---

**文档编写：** 技术架构团队  
**审核人员：** _________________  
**批准日期：** _________________

