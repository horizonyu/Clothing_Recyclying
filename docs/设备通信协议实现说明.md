# 设备通信协议实现说明

## 📋 实现概述

已根据《旧物回收通信协议.docx》完成 4G 设备与后台服务的通信协议实现。

## ✅ 已实现功能

### 1. 二维码方式（已存在）

- ✅ 二维码生成逻辑（硬件端）
- ✅ 二维码解析接口（`POST /api/v1/order/scan`）
- ✅ 签名验证机制
- ✅ 订单创建和领取流程

### 2. 通信方式

| 优先级 | 方式 | 端点 | 说明 |
|--------|------|------|------|
| ⭐ 1 | **WebSocket 长连接** | `ws://server/api/v1/device/ws/{device_id}` | 双向持久连接，心跳/上报/命令全走同一通道 |
| 2 | HTTP 长轮询 | `GET /api/v1/device/listen/{device_id}` | 设备周期性发起请求等待命令推送 |
| 3 | HTTP 短连接 | `POST /api/v1/device/report` 等 | 传统请求-响应，命令通过数据库排队 |

### 3. 设备通信接口

#### 3.1 API接口

| 接口 | 方法 | 说明 |
|------|------|------|
| `/api/v1/device/ws/{device_id}` | **WebSocket** | **⭐ 推荐：设备双向长连接（心跳+上报+命令接收）** |
| `/api/v1/device/report` | POST | 设备常规状态上报（HTTP 短连接） |
| `/api/v1/device/heartbeat` | POST | 设备心跳上报（HTTP 短连接） |
| `/api/v1/device/listen/{device_id}` | GET | 设备长轮询监听命令（向下兼容） |
| `/api/v1/device/query-status` | POST | 后台主动查询设备状态 |
| `/api/v1/device/pending-commands/{device_id}` | GET | 设备轮询待执行命令（向下兼容） |
| `/api/v1/device/time-sync` | POST | 后台下发时间同步 |

#### 3.2 核心组件

1. **设备连接管理器** (`app/services/device_service.py` - `DeviceConnectionManager`)
   - 统一管理 WebSocket 和长轮询两种实时连接
   - `ws_connect()` / `ws_disconnect()` - WebSocket 连接管理
   - `ws_send()` - 通过 WebSocket 发送消息
   - `get_lp_channel()` - 获取长轮询命令通道
   - `send_to_device()` - 统一命令发送（优先 WS > LP）
   - `get_connection_type()` - 获取设备连接类型
   - `get_online_summary()` - 获取在线设备统计

2. **设备服务层** (`app/services/device_service.py` - `DeviceService`)
   - `verify_check_code()` - MD5校验码验证
   - `process_device_status_report()` - 处理状态上报
   - `process_heartbeat_report()` - 处理心跳上报
   - `send_command()` - 发送命令（WebSocket > 长轮询 > 数据库排队）
   - `build_server_ack()` - 创建应答报文
   - `build_time_sync()` - 创建时间同步报文

3. **API接口** (`app/api/v1/device_communication.py`)
   - `device_websocket()` - **WebSocket 双向长连接端点**
   - `device_status_report()` - 设备状态上报接口
   - `device_heartbeat()` - 心跳上报接口
   - `device_listen()` - 长轮询监听接口（向下兼容）
   - `query_device_status()` - 后台主动查询
   - `get_pending_commands()` - 设备轮询待执行命令
   - `send_time_sync()` - 时间同步指令

## 🔧 使用方式

### WebSocket 长连接（推荐）

```python
# Python 示例（设备端）
import asyncio
import websockets
import json

async def device_main():
    ws_url = "ws://42.194.134.223:8000/api/v1/device/ws/DEV001"
    
    async with websockets.connect(ws_url) as ws:
        print("已连接到后台")
        
        # 发送心跳
        heartbeat = {
            "msg_type": "heartbeat_report",
            "device_id": "DEV001",
            "timestamp": "2026-02-08 10:00:00",
            "check_code": "..."  # MD5 校验码
        }
        await ws.send(json.dumps(heartbeat))
        
        # 接收 ack
        ack = json.loads(await ws.recv())
        print(f"收到 ack: {ack}")
        
        # 接收 time_sync
        ts = json.loads(await ws.recv())
        print(f"收到时间同步: {ts}")
        
        # 持续监听后台推送的命令
        while True:
            msg = json.loads(await ws.recv())
            if msg["msg_type"] == "query_device_status":
                print("收到查询命令，立即采集并上报状态...")
                # 上报状态（通过同一个 WebSocket 连接）
                status_report = {...}  # 构建状态上报报文
                await ws.send(json.dumps(status_report))

asyncio.run(device_main())
```

### HTTP 状态上报（向下兼容）

```bash
curl -X POST http://42.194.134.223:8000/api/v1/device/report \
  -H "Content-Type: application/json" \
  -d '{
    "msg_type": "device_status_report",
    "device_id": "DEV001",
    "timestamp": "2026-01-30 10:00:00",
    "check_code": "计算得到的MD5值",
    "data": {
      "battery_level": 85,
      "location": { "longitude": 113.9423, "latitude": 22.5431, "address": "XX路" },
      "smoke_sensor_status": 0,
      "recycle_bin_full": 0,
      "delivery_window_open": 0,
      "is_using": 0,
      "camera_data": { "camera_1": [], "camera_2": [] }
    }
  }'
```

### HTTP 心跳上报（向下兼容）

```bash
curl -X POST http://localhost:8000/api/v1/device/heartbeat \
  -H "Content-Type: application/json" \
  -d '{
    "msg_type": "heartbeat_report",
    "device_id": "DEV001",
    "timestamp": "2026-01-30 10:00:00",
    "check_code": "计算得到的MD5值"
  }'
```

## 📝 报文格式

### 完整报文（含包头包尾）

```
0x6868{JSON数据体}0x1616
```

> **WebSocket 模式下**：设备可直接发送纯 JSON，也可发送带包头包尾的完整报文，后台均能正确解析。

### MD5校验码计算

```python
import hashlib, json

PACKET_HEADER = "0x6868"

def calculate_check_code(packet_data: dict) -> str:
    data_copy = {k: v for k, v in packet_data.items() if k != "check_code"}
    json_str = json.dumps(data_copy, ensure_ascii=False, separators=(',', ':'))
    check_str = PACKET_HEADER + json_str
    return hashlib.md5(check_str.encode('utf-8')).hexdigest()
```

## 📊 数据流程

### WebSocket 长连接流程（推荐）⭐

```
4G设备                           后台服务
   |                                |
   |═══ WebSocket 连接 ═══════════>|  ws://server/api/v1/device/ws/{id}
   |    (持久双向长连接)            |  → 标记设备上线
   |                                |
   |─── 心跳报文 ────────────────>|  heartbeat_report
   |<── ack + time_sync ──────────|  立即响应
   |                                |
   |─── 状态上报 ────────────────>|  device_status_report
   |<── ack (+ time_sync首次) ───|  立即响应
   |                                |
   |                                |<── 管理员点击"查询"
   |<══ 立即收到命令 ═════════════|  query_device_status (推送)
   |─── 采集并上报 ─────────────>|  device_status_report
   |<── ack ─────────────────────|
   |                                |
   |    (连接断开)                  |
   | ═══ 断开 ═════════════════>  |  → 标记设备离线
```

### HTTP 长轮询流程（向下兼容）

```
4G设备                     后台服务                   管理后台
   |                          |                          |
   |=== 长轮询连接 =========>|                          |
   |  GET /device/listen     |                          |
   |  (连接保持挂起)          |                          |
   |                          |<-- 管理员点击"查询" -----|
   |                          |                          |
   |<== 立即收到命令 ========|  asyncio.Queue 推送      |
   |  query_device_status    |                          |
   |                          |                          |
   |--- 采集并上报 --------->|                          |
   |  POST /device/report    |-- 更新设备状态           |
   |<-- server_ack应答 ------|                          |
```

### 命令下发优先级

```
管理员点击"查询设备状态"
       │
       ▼
  ┌─── WebSocket 在线? ───┐
  │ Yes                    │ No
  │ → ws.send_json()      │
  │ → delivery=websocket   ▼
  │                  ┌─── 长轮询在线? ───┐
  │                  │ Yes                │ No
  │                  │ → Queue.put()      │
  │                  │ → delivery=LP      │ → 保存 pending_command
  │                  │                    │ → delivery=queued
  └──────────────────┘                    │ → 心跳时获取
                                          └──────────────────┘
```

### 小程序扫码流程

```
4G设备              用户手机              后台服务
   |                   |                    |
   |-- 生成二维码 ----->|                    |
   |                   |-- 微信扫一扫 ------>|
   |                   |                    |-- 验证MD5校验码
   |                   |                    |-- 创建订单
   |                   |<-- 订单详情 --------|
   |                   |                    |
   |                   |-- 确认领取 -------->|
   |                   |<-- 领取成功 --------|
```

## 🔐 安全机制

### 1. MD5校验码验证

- 所有报文必须包含 `check_code` 字段
- 校验范围：包头(0x6868) + JSON数据体（不含check_code）
- 校验失败：丢弃报文，不处理

### 2. 时间戳验证

- 设备时间戳必须在服务器时间 ±5分钟 内
- 超出范围的报文丢弃
- 通过 time_sync 指令校正设备时钟

### 3. 设备注册验证

- 设备ID必须在数据库中已注册
- 未注册设备的报文直接丢弃

## 🧪 测试

### 1. 使用测试脚本

```bash
cd backend
python scripts/test_heartbeat.py
```

### 2. 手动测试

```bash
# 查看API文档（需DEBUG=true）
http://localhost:8000/docs

# 在文档中找到 "设备通信" 标签下的接口进行测试
```

## ⚠️ 注意事项

1. **推荐 WebSocket**：设备端应优先使用 WebSocket 长连接 (`ws://server/api/v1/device/ws/{device_id}`)
2. **心跳频率**：协议规定每8小时上报一次心跳（WebSocket 模式下可更频繁以保活）
3. **状态上报**：设备状态变化时主动上报
4. **时间同步触发条件**：
   - **首次上报**：设备首次向后台上报数据时（`first_report_at` 为 NULL），后台返回 `ack + time_sync`
   - **心跳**：后台收到心跳后自动下发 `time_sync`
   - **注意**：`is_using` 字段仅表示设备当前是否有人使用，不参与首次上报判断
5. **命令下发优先级**：WebSocket > 长轮询 > 数据库排队
   - WebSocket 在线时命令直接推送
   - 长轮询在线时通过 asyncio.Queue 推送
   - 设备离线时命令写入 pending_command，下次心跳获取
6. **WebSocket 断线处理**：连接断开时自动标记设备为离线；设备应实现自动重连机制
7. **校验失败**：MD5校验失败的报文直接丢弃，不返回应答
8. **摄像头数据**：Base64编码的图片数据，每个摄像头最多3张
9. **设备ID格式**：`DEV_YYYYMMDDXXXX`，如 `DEV_202601300001`
10. **首次上报判断**：通过 `devices` 表的 `first_report_at` 字段判断，为 NULL 即首次上报

## 📚 相关文档

- [设备通信协议设计文档](./设备通信协议设计文档.md)
- [数据库表结构说明](./数据库表结构说明.md)
- [API接口文档](http://localhost:8000/docs)（启动服务后访问）

---

**实现完成时间**：2026-02-08  
**版本**：v3.0 (WebSocket 长连接支持)  
**参考文档**：《旧物回收通信协议.docx》
